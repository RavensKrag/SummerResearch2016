#!/usr/bin/env ruby
# encoding: utf-8

# gems for rake
require 'rubygems'

require 'rake'
require 'rake/clean'
require 'rake/testtask'

# constants
PATH_TO_FILE = File.expand_path(File.dirname(__FILE__))

# gems (for everything else)
require 'bundler/setup'

require 'require_all'
require 'open-uri'
require 'nokogiri'
require 'yaml'
require 'csv'

# files
require_all 'lib/SummerResearch'

# require './main'



# setup tests
Rake::TestTask.new do |t|
	t.libs = []
	t.test_files = FileList['test/test*.rb']
	t.verbose = true
end


# =============================================



# task :default => :run


# Run multiple pathways with a single command
# usage: rake pathways[1,2,3]
# 
#           positional arguments only, no named args
#               V
task :pathways, [] => [:load_dependencies, :setup_data] do |t, args|
	pathway_numbers = args.extras.collect{|x| x.to_i }
	
	puts "pathways: #{pathway_numbers.inspect}"
	
	pathway_numbers.each do |number|
		Rake::Task["pathway#{number}".to_sym].invoke()
	end
end




task :setup_data do

end

# ok, this is pretty solid...
# but what happens when you get mulitple intermediates out of one process?
# (similar to a multiple return)


# Check out this question on StackOverflow that deals with this exact situation:
# src: http://stackoverflow.com/questions/24026092/rake-task-with-multiple-prerequisites-generating-multiple-outputs

# based on that answer, I wrote this:
# foo = {
# 	:targets     => %w[target1.txt target2.txt],
# 	:shared_deps => %w[src1.txt src2.txt],
# 	:callback => ->(){
		
# 	}
# }
# foo[:targets].each do |filename|
# 	file filename => foo[:shared_deps] do |t|
# 		foo[:callback]
# 	end
# end


# Declare a file task that generates mulitple files with the same prerequisites.
# (actually will generate multiple tasks, but this is a nice convienence)
def multi_file(args={}, &block)
	# kinda a hacky way of getting the Rake-style interface.
	# Should probably see what Rake actually does,
	# because this is not sophisticated enough to be how Rails works.
	outputs        = args.keys.first
	shared_prereqs = args.values.first
	
	outputs.each do |filename|
		file filename => shared_prereqs do |t|
			block.call(t)
		end
		# there should be a way to just pass the block, instead of calling a block from a block
		# but that way is complicated and arcane, so don't do it.
		# 
		# This way is simple to understand.
	end
end

multi_file %w[target1.txt target2.txt] => %w[src1.txt src2.txt] do
	
end






	@dataset0 = [
		"Computer Science",
		"Information Technology",
		"Electrical Engineering",
		"Biology",
		"Psychology"
	]
	
	
	@dataset1 = [
		"Computer Science, BS",
		"Applied Computer Science, BS",
		"Biology, BA",
		"Biology, BS",
		"Psychology, BA"
	]
	
	
	@dataset2 = ["CS", "BIOL", "CHEM", "PSYC"]
	
	
	# Test course_info on various URLs with different sorts of attributes
	# NOTE: not all courses specify all attributes. 
	#   ex) If there are no corequisites, the field is omitted
	@dataset3 = [
		["CS 330",   "http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302788&print"],
		["STAT 344", "http://catalog.gmu.edu/preview_course.php?catoid=29&coid=306778&print"],
		["PSYC 320", "http://catalog.gmu.edu/preview_course.php?catoid=29&coid=306130&print"]
	]
	
	
	@dataset4 = [
		[
			"CS 101",
			"Preview of Computer Science",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302776&print"
		],
		[
			"CS 465",
			"Computer Systems Architecture",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302800&print"
		],
		[
			"CS 475",
			"Concurrent and Distributed Systems",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302803&print"
		],
		[
			"EVPP 110",
			"The Ecosphere: An Introduction to Environmental Science I",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=303982&print"
		],
		[
			"Mason Core UGU",
			"Global Understanding",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=308635"
		]
	]




# get programs of study from the catalog
def foo1
	return if @degrees
	
	list_of_degrees = @dataset0
	
	# --------
	
	# TODO: all URL handling code should be aware that the catoid parameter controls what catalog year is being used.
	
	# NOTE: file needs to be rebuilt when the variable @dataset0 changes. how you check for that?
	
	degrees = SummerResearch.search_programs_of_study(list_of_degrees)
	
	count = degrees.keys.size
	puts "#{count} programs found for search query."
	
	# --------
	
	filepath = 'bin/data/programs_of_study.yaml'
	puts "Writing to file '#{filepath}'"
	SummerResearch::Utilities.write_to_file(filepath, degrees.to_yaml )
	
	@degrees = degrees
end

# get the list of courses for one program, based on its name
def foo2
	return if @required_courses
	
	@degrees ||= YAML.load_file('bin/data/programs_of_study.yaml')
	
	degree_name = "Computer Science, BS"
	
	# --------
	
	url = @degrees[degree_name]
	
	course_list = SummerResearch.degree_requirements(url) # <-- make this better
	# puts course_list.to_yaml
	
	# TODO: remove dupicate entries in the list of courses
		# not just as simple as removing duplicates from list
		# need to remove when two tuples have the same first element
		# also - want to keep original ordering
	# NOTE: this may not be necessary if the selection filter on links is improved
	
	# --------
	
	filepath = 'bin/data/required_courses.csv'
	SummerResearch::Utilities.write_csv(filepath, course_list)
	
	@required_courses = course_list
end

def foo3
	# code taken from foo5
	list_of_deparments = @dataset2
	
	# --------
	
	courses = list_of_deparments.collect{  |dept|
	          	# SummerResearch.courses_in_department => 'bin/data/search.html'
	          	[dept, SummerResearch.courses_in_department(dept)]
	          }.to_h
	
	# --------
	
	SummerResearch::Utilities.write_to_file('bin/data/courses.yaml', courses.to_yaml )
	
	@courses = courses
end

def foo4
	# code taken from foo4
	# (this is the same data as required_courses.csv?)
	# 
	# no it's not. this is the list of all courses in one department.
	# (ID, short description (title?), and links. not full data)
	
	# depends on pulling data down from the catalog from a department?
	# thus, the data writing should not happen here, but the prereq to this
	
	@courses ||= YAML.load_file('bin/data/courses.yaml')
	
	course_id = "CS 101"
	# --------
	
	# TODO: figure out what the anatomy of a course is
	# * CS 101
	# * Preview of Computer Science
	# * Description
	# * Section ID?
	# --- these are all different things
	
	dept, number = course_id.split
	course = @courses[dept].find{  |x| x.id.include? number }
	# TODO: if department is not found, error should alert the user that list of courses needs to be pulled down from the Catalog for that department before asking for a course.
	
	
	course_info = SummerResearch::CourseInfo.new(course).fetch
	p course_info
	
	# --------
end


task :foo, [] do |t, args|
	pathway_numbers = args.extras.collect{|x| x.to_i }
	
	puts "foo: #{pathway_numbers.inspect}"
	
	pathway_numbers.each do |number|
		eval "foo#{number}()"
	end
end

# foo1()
# foo2()
# foo3()
# foo4()




file 'bin/data/course_info.yaml' => 
['bin/data/required_courses.csv', 'bin/data/courses.yaml'] do |t|
	# code taken from foo13
	
	@required_courses ||= SummerResearch::Utilities.load_csv_file(t.prerequisites[0])
	@courses          ||= YAML.load_file(t.prerequisites[1])
	
	dept = "CS"
	course_list = @required_courses + @courses[dept]
	
	# --------
	
	# this is a very simple routine. does not need to be it's own function

	# similar to the tests (very similar to foo12),
	# but this is an actual procedure
	# (subroutine. used to generate intermediates. should probably parameterize output path?
	# (or maybe just return data, and not write to file)
	
	output_data = 
		course_list.collect do |course|
			puts course.id
			SummerResearch::CourseInfo.new(course).fetch
		end
	
	SummerResearch::Utilities.write_to_file('./course_info.yaml', output_data.to_yaml )
	
	return output_data
	
	# --------
	
	# return output_data
end


file 'bin/data/search.html' => [] do |t|
	# generated by courses_in_department(dept_code)
end



task :default => :run

task :run => [:setup_data, :from_foo4]









# this is just a template
# 1 2 3 (list the full foo execution chain?)
task :pathwayX => :setup do
	
end





