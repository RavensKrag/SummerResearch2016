# encoding: utf-8

# gems
require 'rubygems'

require 'rake'
require 'rake/clean'

require 'bundler/setup'
require 'require_all'

# constants
PATH_TO_FILE = File.expand_path(File.dirname(__FILE__))

# -- file hierarchy --
		# ROOT
		# 	this directory
		# 		this file

# Must expand '..' shortcut into a proper path. But that results in a shorter string.
PATH_TO_ROOT = File.expand_path '../..', __FILE__






task :load_dependencies do
	# gems
	require 'open-uri'
	require 'nokogiri'
	require 'yaml'
	require 'csv'
	
	# files
	Dir.chdir PATH_TO_ROOT do
		require_all './lib/SummerResearch'
	end
end

task :load_main do
	require './main'
end


task :default => :run

# run the program
task :run => [:load_dependencies, :load_main] do
	x = SummerResearch::Main.new
	
	
	# consider different forms of caching
	# -- instance variable: cache for the session
	# -- save to disk: cache for multiple sessions
	
	[
		"Computer Science, BS",
		"Applied Computer Science, BS",
		"Biology, BA",
		"Biology, BS",
		"Psychology, BA"
	]
	
	
	# pathway0
	# pathway1(x)
	# pathway2(x)
	# pathway3(x)
	pathway4(x)
end


def pathway0
	# === scrape the list of avaiable courses from the Catalog, searching for particular things
	programs_of_study = search_programs_of_study [
							"Computer Science",
							"Information Technology",
							"Electrical Engineering",
							"Biology",
							"Psychology"
						]
	puts "programs of study: #{programs_of_study.size}"
	puts ""
	
	
	
	
	# === scrape program of study page to get list of required courses
	
	# degree_requirements(programs_of_study["Computer Science, BS"])
	# degree_requirements(programs_of_study["Applied Computer Science, BS"])
	degree_requirements(programs_of_study["Biology, BA"])
	# degree_requirements(programs_of_study["Biology, BS"])
end

def pathway1(x)
	x.foo1 [
		"Computer Science",
		"Information Technology",
		"Electrical Engineering",
		"Biology",
		"Psychology"
	]
	courses = x.foo2("Computer Science, BS")
	x.foo11(courses)
	
	
	x.foo3()
end

def pathway2(x)
	deparments = ["CS", "BIOL", "CHEM", "PSYC"]
	x.foo5(deparments)
	
	# x.foo5(["CS"])
	
	x.foo4()
end

def pathway3(x)
	x.foo1([
		"Computer Science",
		"Information Technology",
		"Electrical Engineering",
		"Biology",
		"Psychology"
	])
	x.foo6() # NOTE: foo6 not yet properly ported
end

def pathway4(x)
	# pull down a bunch of data
	x.foo1([
		"Computer Science",
		"Information Technology",
		"Electrical Engineering",
		"Biology",
		"Psychology"
	])
	x.foo5( ["CS", "BIOL", "CHEM", "PSYC"] )
	# TODO: cache 1 and 5 to speed up evaluation
	
	
	[
		"Computer Science, BS",
		"Applied Computer Science, BS",
		"Biology, BA",
		"Biology, BS",
		"Psychology, BA"
	]
	
	# take one degree program, and walk the dependencies for all courses in the degree
	course_list = x.foo7("Computer Science, BS")  # get all relevant courses
	class_dependencies = x.foo8(course_list)      # construct all dependencies
	
	output_filepath = ""
	x.foo10(class_dependencies, output_filepath)  # visualize the dependency graph
	
	
	# query: what is the chain of courses that lead up to this course? 
	x.foo9(class_dependencies, "CS 465")
	# => [CS 367, ECE 301, CS 262, CS 211, CS 112, MATH 113, CS 101?]
	
	# TODO: This is actually not properly a list, it is a subgraph. Some dependencies do not lie along the main path. How do you display that information?
	# NOTE: "ECE 301" is the old name, IIRC
end

