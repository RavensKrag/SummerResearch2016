#!/usr/bin/env ruby
# encoding: utf-8

# gems
require 'rubygems'

require 'rake'
require 'rake/clean'

require 'bundler/setup'
require 'require_all'

# constants
PATH_TO_FILE = File.expand_path(File.dirname(__FILE__))

# -- file hierarchy --
		# ROOT
		# 	this directory
		# 		this file

# Must expand '..' shortcut into a proper path. But that results in a shorter string.
PATH_TO_ROOT = File.expand_path '../..', __FILE__


# gems
require 'open-uri'
require 'nokogiri'
require 'yaml'
require 'csv'

# files
Dir.chdir PATH_TO_ROOT do
	require_all './lib/SummerResearch'
end

require './main'



# task :default => :run

# run the program
# task :run => [:setup] do
# 	p @env
# 	# consider different forms of caching
# 	# -- instance variable: cache for the session
# 	# -- save to disk: cache for multiple sessions
	
# 	# TODO: consider promoting pathway4 as the default?
# end

# all root tasks should list this as a dependency
task :setup => [:load_dependencies, :load_main, :setup_data] do
	puts "=== setup environment"
	# @env = SummerResearch::Main.new
end

# task :all => [
# 	:pathway1,
# 	:pathway2,
# 	:pathway3,
# 	:pathway4,
# 	:pathway5,
# 	:pathway6,
# 	:pathway8,
# 	:pathway7
# ]


# 1
task :pathwayA => :setup do
	puts "=== setup data"
	# search for relevant programs of study
	# (required to run #foo2)
	@env.foo1 [
		"Computer Science",
		"Information Technology",
		"Electrical Engineering",
		"Biology",
		"Psychology"
	]
end

# 5
task :pathwayB => :setup do
	# search catalog for even more data?
	deparments = ["CS", "BIOL", "CHEM", "PSYC"]
	@env.foo5(deparments)
end



# 1 2 3
task :pathway1 => :pathwayA do
	courses = @env.foo2("Computer Science, BS")
	
	@env.foo3()
	
	#  1  load degrees
	#  2  get courses from CS degree
	#  3  test certain classes, to make sure they parse (DEPRECIATED FUNCTION)
end

# 5 4
task :pathway2 => :setup do
	@env.foo5(["CS"])	
	@env.foo4()
	
	#  5  load courses by department code
	#  4  pick out a specific course by ID, fetch that data using CourseInfo object
end

# 1 6
task :pathway3 => :pathwayA do
	@env.foo6() # NOTE: foo6 not yet properly ported
	
	#  1  load degrees
	#  6  get full program requirements logic (more than just course dependencies)
end

# 1 5 7 8 10 9
task :pathway4 => [:pathwayA, :pathwayB] do
	#  1  load degrees
	#  5  load courses by department code
	#  7  scrape all links from overview of one degree. no degree requenments, just a dumb list.
	#  8  Backend dependency graph construction.
	# 10  visualization of graph
	#  9  queries on the graph
	 
	
	# TODO: cache 1 and 5 to speed up evaluation
	
	
	
	puts "=== run processing"
	
	[
		"Computer Science, BS",
		"Applied Computer Science, BS",
		"Biology, BA",
		"Biology, BS",
		"Psychology, BA"
	]
	
	# take one degree program, and walk the dependencies for all courses in the degree
	course_list = @env.foo7("Computer Science, BS")  # get all relevant courses
	class_dependencies = @env.foo8(course_list)      # construct all dependencies
	
	output_filepath = ""
	@env.foo10(class_dependencies, output_filepath)  # visualize the dependency graph
	
	
	# query: what is the chain of courses that lead up to this course? 
	@env.foo9(class_dependencies, "CS 465")
	# => [CS 367, ECE 301, CS 262, CS 211, CS 112, MATH 113, CS 101?]
	
	# TODO: This is actually not properly a list, it is a subgraph. Some dependencies do not lie along the main path. How do you display that information?
	# NOTE: "ECE 301" is the old name, IIRC
end

# 1 2 13
task :pathway5 => :pathwayA do
	#  1  load degrees
	#  2  get courses from CS degree
	# 13  fetch all courses in list, and write data to file (also return) (input: course structs)
	
	courses = @env.foo2("Computer Science, BS")
	
	
	puts "=== run processing"
	course_data = @env.foo13(courses)
end

# test course parsing with a couple of key examples
# (TODO: take extra data from foo3 and move into foo12 for more variety of data)
# 1 2 12 11
task :pathway6 => :pathwayA do
	#  1  load degrees
	#  2  get courses from CS degree
	# 12  encode sample course data as CatalogLink structs
	# 11  try to fetch data for courses listed. light debug info. can quickly indenitfy problems.
	
	courses = @env.foo2("Computer Science, BS")
	
	
	puts "=== run processing"
	
	courses = @env.foo12()
	course_data = @env.foo11(courses)
end

# test course parsing with a couple of key examples
# Test for different types of course description pages
# 1 2 12 14
task :pathway8 => :pathwayA do
	#  1  load degrees
	#  2  get courses from CS degree
	# 12  encode sample course data as CatalogLink structs
	# 14  try to fetch data for courses listed. verbose debug mode. basically everything you need.
	
	courses = @env.foo2("Computer Science, BS")
	
	
	puts "=== run processing"
	
	courses = @env.foo12()
	course_data = @env.foo14(courses)
end

# test all courses across various majors to make sure everything runs correctly
# uses foo11 to detect which courses have odd link formats
# 1 2 11
task :pathway7 => :pathwayA do	
	#  1  load degrees
	#  2  get courses from CS degree
	# 11  try to fetch data for courses listed. light debug info. can quickly indenitfy problems.
	
	puts "=== cycle through programs of study..."
	
	programs = [
		"Computer Science, BS",
		"Applied Computer Science, BS",
		"Biology, BA",
		"Biology, BS",
		"Psychology, BA"
	]
	programs.each do |degree_name|
		puts "=== Getting info for: #{degree_name}"
		courses = @env.foo2(degree_name)
		# If the program list has a weird link in it, then the foo2 will fail before reaching the end of the list
			# url = @env.degrees[degree_name]
			# course_list = degree_requirements(url)
			# puts "test"
		# failure occurs inside of degree_requiremnts
		
		puts "=== analyzing courses... "
		course_data = @env.foo11(courses)
	end
	
	# errors from: SummerResearch::CourseInfo#fetch
	# two other page formats:
		# +  new page format: attemps to give more structure using <p> to separate into sub-regions, but actually malformed
			# ^ seems to be for more recent courses? not really sure why the markup is different
		# +  Mason Core pages: Totally different pages, because these are not actually courses. They are "aliases" of sorts for entire lists of courses.
	
	
	
	# NOTE: perhaps not all majors work right now? so be careful of that too
	
	
	
	# NOTE: the following programs of study only use Type A or Type B catalog links
		# "Computer Science, BS",
		# "Biology, BA",
	# NOTE: the following programs of study are known to list courses with Type C catalog links
		# "Applied Computer Science, BS",
		# "Biology, BS",
		# "Psychology, BA"
end


# Now that we have the data, actually start to walk it and do something interesting with it.
# (actually, may want to just go back to pathway4 instead)
# precedesssor: pathway4
# 1 5 7 8
task :pathway9 => [:pathwayA, :pathwayB] do
	#  1  load degrees
	#  5  load courses by department code
	#  7  scrape all links from overview of one degree. no degree requenments, just a dumb list.
	#  8  Backend dependency graph construction.
	
	
	# TODO: cache 1 and 5 to speed up evaluation
	
	
	puts "=== run processing"
	
	
	# TODO: output data on different degrees to different folders.
	# probably need to restructure some other code, such that the output directory is configurable?
	
	[
		"Computer Science, BS",
		"Applied Computer Science, BS",
		"Biology, BA",
		"Biology, BS",
		"Psychology, BA"
	]
	
	# take one degree program, and walk the dependencies for all courses in the degree
	course_list = @env.foo7("Computer Science, BS")  # get all relevant courses
	class_dependencies = @env.foo8(course_list)      # construct all dependencies
	
	puts "============"
	
	
	# =====
	puts "Filtering courses..."
	better_list = 
		course_list.reject{  |course| course.id == "Mason Core" }
		           .uniq{  |a| a.id    }
		           .sort_by{  |a| a.id.split(' ').first   }
	
	puts "=== download individual course data..."
	course_info_list = better_list.collect do |x|
		print '.'
		SummerResearch::CourseInfo.new(x).fetch
	end
	
	SummerResearch::Utilities.write_to_file("./all_course_data.yaml", course_info_list.to_yaml)
	
	# could pull down *list* of all courses associated with a dept
	# if courses in a major have prereqs in that department?
	# (definitely don't actually pull down each and every course before filtering though...)
	
	# under the current pipeline, I think this is the only way to do things?
	# can't ask for a single class by course ID until you have a list of all courses by dept
	# (foo4 experiments with this, but currently does not except a parameter)
	
	# department_codes = better_list.collect{ |course| course.id.split(' ').first }.uniq
end

# must run pathway9 before this, but can't list as explict dependency,
# because I want to be able to run pathway9 and pathway10 in separate executions
# (kinda like caching?)
task :pathway10 => :setup do
	# @env is active in this block, but can't actually be meaningully used
	# bascially, you should only interact with the data from the yaml file in this block,
	# otherwise weird things will happen
	
	# TODO: this code, when completed, should be moved under foo8
	
	course_info_list = SummerResearch::Utilities.load_yaml_file("./all_course_data.yaml")
	
	
	puts "=== process data..."
	course_info_list.each do |course_info|
		puts "#{course_info.id} - #{course_info.title}"
		
		regexp = /(\p{L}+ \d+)/
		
		# Explict dependencies
		
		
		hard_deps =
			%w[Prerequisite(s) Corequisite(s)]
				.collect do |x|
					requirements = course_info[x]
					p requirements
					next unless requirements
					requirements.scan(regexp)
				end
				
		
		# "C or higher in CS 105; (COMM 100, and ENGH 302) or (HNRS 110 and HNRS 122, 130, 131, 230 or 240); junior standing (at least 60 credit hours)."
		# ERROR: can't deal with 'or 240'
		# ERROR: can't deal with 'at least 60 credit hours' => 'least 60'
		
		# "Grade of C or better in CS 310, 330, and 367."
		# ERROR: can't deal with 'CS 310, 330, and 367' => 'and 367'
		
		# CS 499 
		# Prerequisite(s): 60 credits and permission of instructor; specific prerequisites vary with nature of topic.
		
		# PHIL 371 - Philosophy of Natural Sciences
		# Prerequisite(s): "3 credits of philosophy, or permission of instructor"
		
		
		
		# "#{course} with grade of C or better"
		# "Minimum grade of C in #{course}"
		soft_deps = 
			if course_info["Notes"]
				# [0] PHYS 161
				# [1] PHYS
				# [2] 161
				
				# soft_deps = course_info["Notes"].scan(regexp).collect{ |matches| matches[0] }
				[] # pseudo-return empty array to stub this out
			else
				[] # if "Notes" attribute not set, return empty Array
			end
		
		
		# p hard_deps
		# p soft_deps
		dependencies = hard_deps + soft_deps
		
		
		p dependencies.flatten.compact.uniq
		puts "---------"
	end
end

# TODO: print list of courses for a degree, chunked by what sector they appear in in the Program of Study page. This, in conjunction with the dependency info printed in pathway10, can be used to generate visualizations.

task :pathway11 => :setup do
	
end





# Run multiple pathways with a single command
# usage: rake pathways[1,2,3]
# 
#           positional arguments only, no named args
#               V
task :pathways, [] => [:load_dependencies, :setup_data] do |t, args|
	pathway_numbers = args.extras.collect{|x| x.to_i }
	
	puts "pathways: #{pathway_numbers.inspect}"
	
	pathway_numbers.each do |number|
		Rake::Task["pathway#{number}".to_sym].invoke()
	end
end




task :setup_data do
	@dataset0 = [
		"Computer Science",
		"Information Technology",
		"Electrical Engineering",
		"Biology",
		"Psychology"
	]
	
	
	@dataset1 = [
		"Computer Science, BS",
		"Applied Computer Science, BS",
		"Biology, BA",
		"Biology, BS",
		"Psychology, BA"
	]
	
	
	@dataset2 = ["CS", "BIOL", "CHEM", "PSYC"]
	
	
	# Test course_info on various URLs with different sorts of attributes
	# NOTE: not all courses specify all attributes. 
	#   ex) If there are no corequisites, the field is omitted
	@dataset3 = [
		["CS 330",   "http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302788&print"],
		["STAT 344", "http://catalog.gmu.edu/preview_course.php?catoid=29&coid=306778&print"],
		["PSYC 320", "http://catalog.gmu.edu/preview_course.php?catoid=29&coid=306130&print"]
	]
	
	
	@dataset4 = [
		[
			"CS 101",
			"Preview of Computer Science",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302776&print"
		],
		[
			"CS 465",
			"Computer Systems Architecture",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302800&print"
		],
		[
			"CS 475",
			"Concurrent and Distributed Systems",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302803&print"
		],
		[
			"EVPP 110",
			"The Ecosphere: An Introduction to Environmental Science I",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=303982&print"
		],
		[
			"Mason Core UGU",
			"Global Understanding",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=308635"
		]
	]
end




# get programs of study from the catalog
file :pathway12 => [:setup] do |t, args|
	# TODO: all URL handling code should be aware that the catoid parameter controls what catalog year is being used.
	
	# NOTE: file needs to be rebuilt when the variable @dataset0 changes. how you check for that?
	list_of_degrees = @dataset0
	
	degrees = SummerResearch.search_programs_of_study(list_of_degrees)
	
	count = degrees.keys.size
	puts "#{count} programs found for search query."
	
	
	
	filepath = "./programs_of_study.yaml"
	puts "Writing to file '#{filepath}'"
	SummerResearch::Utilities.write_to_file(filepath, degrees.to_yaml)
end


[
	'programs_of_study.yaml',
	'p13',
]

task :build => [:setup, 'data/p13']



task 'data/out' => [:connect_to_catalog, 'config/programs.yaml']





# ok, this is pretty solid...
# but what happens when you get mulitple intermediates out of one process?
# (similar to a multiple return)


# Check out this question on StackOverflow that deals with this exact situation:
# src: http://stackoverflow.com/questions/24026092/rake-task-with-multiple-prerequisites-generating-multiple-outputs

# based on that answer, I wrote this:
# foo = {
# 	:targets     => %w[target1.txt target2.txt],
# 	:shared_deps => %w[src1.txt src2.txt],
# 	:callback => ->(){
		
# 	}
# }
# foo[:targets].each do |filename|
# 	file filename => foo[:shared_deps] do |t|
# 		foo[:callback]
# 	end
# end


# Declare a file task that generates mulitple files with the same prerequisites.
# (actually will generate multiple tasks, but this is a nice convienence)
def multi_target(args={}, &block)
	# kinda a hacky way of getting the Rake-style interface.
	# Should probably see what Rake actually does,
	# because this is not sophisticated enough to be how Rails works.
	outputs        = args.keys.first
	shared_prereqs = args.values.first
	
	outputs.each do |filename|
		file filename => shared_prereqs do |t|
			block.call(t)
		end
		# there should be a way to just pass the block, instead of calling a block from a block
		# but that way is complicated and arcane, so don't do it.
		# 
		# This way is simple to understand.
	end
end

multi_target %w[target1.txt target2.txt] => %w[src1.txt src2.txt] do
	
end






# get programs of study from the catalog
file 'data/programs_of_study.yaml' => :setup_data do |t, args|
	list_of_degrees = @dataset0
	
	# --------
	
	# TODO: all URL handling code should be aware that the catoid parameter controls what catalog year is being used.
	
	# NOTE: file needs to be rebuilt when the variable @dataset0 changes. how you check for that?
	
	degrees = SummerResearch.search_programs_of_study(list_of_degrees)
	
	count = degrees.keys.size
	puts "#{count} programs found for search query."
	
	# --------
	
	filepath = t.name
	puts "Writing to file '#{filepath}'"
	SummerResearch::Utilities.write_yaml_file(filepath, degrees)
	
	@degrees = degrees
end


# get the list of courses for one program, based on its name
file 'data/required_courses.csv' => 'data/programs_of_study.yaml' do |t|
	@degrees ||= YAML.load_file(t.prerequisites[0])
	
	degree_name = "Computer Science, BS"
	
	# --------
	
	url = @degrees[degree_name]
	
	course_list = SummerResearch.degree_requirements(url)
	# puts course_list.to_yaml
	
	# TODO: remove dupicate entries in the list of courses
		# not just as simple as removing duplicates from list
		# need to remove when two tuples have the same first element
		# also - want to keep original ordering
	# NOTE: this may not be necessary if the selection filter on links is improved
	
	# --------
	
	filepath = t.name
	SummerResearch::Utilities.write_csv(filepath, course_list)
	
	@required_courses = course_list
end

file 'data/requirements.html' => [] do |t|
	# this file is generated by requirements_subtree()
end


file 'data/course.html' => [] do |t|
	# generated by CourseInfo #fetch and #test_types
end

file 'data/courses.yaml' => :setup_data do |t|
	# code taken from foo5
	list_of_deparments = @dataset2
	
	# --------
	
	courses = list_of_deparments.collect{  |dept|  [dept, courses_in_department(dept)]  }.to_h
	
	# --------
	
	SummerResearch::Utilities.write_yaml_file('data/courses.yaml', courses)
	
	@courses = courses
end

task :from_foo4 => 'data/courses.yaml' do |t|
	# code taken from foo4
	# (this is the same data as required_courses.csv?)
	# 
	# no it's not. this is the list of all courses in one department.
	# (ID, short description (title?), and links. not full data)
	
	# depends on pulling data down from the catalog from a department?
	# thus, the data writing should not happen here, but the prereq to this
	
	@courses ||= YAML.load_file(t.prerequisites[0])
	
	course_id = "CS 101"
	# --------
	
	# TODO: figure out what the anatomy of a course is
	# * CS 101
	# * Preview of Computer Science
	# * Description
	# * Section ID?
	# --- these are all different things
	
	dept, number = course_id.split
	course = @courses[dept].find{  |x| x.id.include? number }
	# TODO: if department is not found, error should alert the user that list of courses needs to be pulled down from the Catalog for that department before asking for a course.
	
	
	course_info = SummerResearch::CourseInfo.new(course).fetch
	p course_info
	
	# --------
	
	
end


file 'data/course_info.yaml' => [] do |t|
	# code taken from foo13
	
	course_list = []
	
	# --------
	
	# this is a very simple routine. does not need to be it's own function

	# similar to the tests (very similar to foo12),
	# but this is an actual procedure
	# (subroutine. used to generate intermediates. should probably parameterize output path?
	# (or maybe just return data, and not write to file)
	
	output_data = 
		course_list.collect do |course|
			puts course.id
			SummerResearch::CourseInfo.new(course).fetch
		end
	
	SummerResearch::Utilities.write_yaml_file('./course_info.yaml', output_data)
	
	return output_data
	
	# --------
	
	# return output_data
end


file 'data/search.html' => [] do |t|
	# generated by courses_in_department(dept_code)
end



task :default => :run

task :run => [:setup_data, :from_foo4]









# this is just a template
# 1 2 3 (list the full foo execution chain?)
task :pathwayX => :setup do
	
end





