# encoding: utf-8

require 'rubygems'

require 'rake'
require 'rake/clean'
require 'rake/testtask'

require 'bundler'
Bundler.require(:default)
require 'bundler/setup'

# other libraries
require 'yaml'
require 'csv'
require 'set'
require 'open-uri'


# constants
PATH_TO_FILE = File.expand_path(File.dirname(__FILE__))

# -- file hierarchy --
		# ROOT
		# 	this directory
		# 		this file

# Must expand '..' shortcut into a proper path. But that results in a shorter string.
PATH_TO_ROOT = File.expand_path '../..', __FILE__


# files
Dir.chdir PATH_TO_ROOT do
	require_all './lib/SummerResearch'
end


# load main
require './main'

# setup tests
Rake::TestTask.new do |t|
	t.libs = []
	t.test_files = FileList['test/test*.rb']
	t.verbose = true
end

# task :default => :run











# Run multiple pathways with a single command
# usage: rake pathways[1,2,3]
# 
#           positional arguments only, no named args
#               V
task :pathways, [] => [:load_dependencies, :setup_data] do |t, args|
	pathway_numbers = args.extras.collect{|x| x.to_i }
	
	puts "pathways: #{pathway_numbers.inspect}"
	
	pathway_numbers.each do |number|
		Rake::Task["pathway#{number}".to_sym].invoke()
	end
end




# ok, this is pretty solid...
# but what happens when you get mulitple intermediates out of one process?
# (similar to a multiple return)


# Check out this question on StackOverflow that deals with this exact situation:
# src: http://stackoverflow.com/questions/24026092/rake-task-with-multiple-prerequisites-generating-multiple-outputs

# based on that answer, I wrote this:
# foo = {
# 	:targets     => %w[target1.txt target2.txt],
# 	:shared_deps => %w[src1.txt src2.txt],
# 	:callback => ->(){
		
# 	}
# }
# foo[:targets].each do |filename|
# 	file filename => foo[:shared_deps] do |t|
# 		foo[:callback]
# 	end
# end


# Declare a file task that generates mulitple files with the same prerequisites.
# (actually will generate multiple tasks, but this is a nice convienence)
def multi_file(args={}, &block)
	# kinda a hacky way of getting the Rake-style interface.
	# Should probably see what Rake actually does,
	# because this is not sophisticated enough to be how Rails works.
	outputs        = args.keys.first
	shared_prereqs = args.values.first
	
	outputs.each do |filename|
		file filename => shared_prereqs do |t|
			block.call(t)
		end
		# there should be a way to just pass the block, instead of calling a block from a block
		# but that way is complicated and arcane, so don't do it.
		# 
		# This way is simple to understand.
	end
end

# multi_file %w[target1.txt target2.txt] => %w[src1.txt src2.txt] do
	
# end







# =============================================





# could pull down *list* of all courses associated with a dept
# if courses in a major have prereqs in that department?
# (definitely don't actually pull down each and every course before filtering though...)

# under the current pipeline, I think this is the only way to do things?
# can't ask for a single class by course ID until you have a list of all courses by dept
# (foo4 experiments with this, but currently does not except a parameter)

# department_codes = better_list.collect{ |course| course.id.split(' ').first }.uniq















































# TODO: name functions and move them from main.rb to named_functions.rb
# (this will also remove dependence on shared state stored in @env)
# (state should be stored / shared at this level (rake), not within the @env variable)



list_of_degrees = [
	"Computer Science",
	"Information Technology",
	"Electrical Engineering",
	"Biology",
	"Psychology"
]

degrees = SummerResearch.search_programs_of_study(list_of_degrees)


count = degrees.keys.size
puts "#{count} programs found for search query."

SummerResearch::Utilities.write_to_file("./programs_of_study.yaml", degrees.to_yaml)
@programs_of_study = degrees






	
	
# === take one degree program, and walk the dependencies for all courses in the degree
# (get all relevant courses)

program_name = "Computer Science, BS"
url = @programs_of_study[program_name]

fragment = SummerResearch.requirements_subtree(url)

# TODO: need to improve this selector. catching some false positives.
# wait, variable 'fragment' is a list...
course_list = SummerResearch.get_all_weird_link_urls(fragment)



# TODO: remove dupicate entries in the list of courses
	# not just as simple as removing duplicates from list
	# need to remove when two tuples have the same first element
	# also - want to keep original ordering
# NOTE: this may not be necessary if the selection filter on links is improved

SummerResearch::Utilities.write_to_file("./required_courses.yaml", course_list.to_yaml)

@required_courses = course_list



class_dependencies = SummerResearch.foo8(course_list)      # construct all dependencies



->(){
	

	puts "Filtering courses..."
	filtered_list = 
		@required_courses.reject{  |course| course.id == "Mason Core" }
		                 .uniq{  |a| a.id    }
		                 .sort_by{  |a| a.id.split(' ').first   }
	
	puts "=== recursive download of dependencies... "
	
	
	
	
	# recursive traversal
	# (iterative implementation, breadth first traversal)
	
	input_list = filtered_list.collect{  |cat_link| cat_link.id  }.uniq
	
	all_info_pages = Array.new
	
	# input_list     - array of strings, ex) ["CS 101", "CS 330", "CS 499"]
	# all_info_pages - collection of CourseInfo objects (should all be unique)
		# NOTE: equality of CourseInfo objects within a Set not yet defined
	until input_list.empty? do
		puts "-- downloading..."
		info_pages = input_list.collect{  |course_id|  print'.'; @catalog.download_course_info(course_id) }
		puts ""
		nested_ids = info_pages.collect{  |info| SummerResearch.list_dependencies(info)  }
			# [[id, id, id], [id, id]]
		
		puts "-- update"
		# add recently downloaded data into the greater collection (in-memory cache)
		all_info_pages += info_pages
		
		puts "-- calculate courses to check"
		# all dependencies at this level
		new_dependencies = nested_ids.flatten.compact.uniq
			# [id, id, id, id]
		
		# all dependencies where data has not yet been fetched
		dep_set           = new_dependencies.to_set                           # set of strings
		detailed_info_set = all_info_pages.collect{  |info| info.id  }.to_set # set of strings
		new_deps          = dep_set.difference(detailed_info_set)
		
		# fetch new specific data
		input_list = new_deps.to_a
		
		p input_list
	end
	# TODO: like other testing, alert when there is an error with parsing dependencies for a course, but continue on to the other courses. I would like to be able to see some trends in anamolous data.
	
	
	
	SummerResearch::Utilities.write_to_file("./all_course_data.yaml", all_info_pages.to_yaml)
	@full_dependency_list = all_info_pages
}





# file "data/all_course_data.yaml" => ["data/required_courses.yaml", "data/catalog.yaml"] do
task :new_pathway4 => ["data/required_courses.yaml", "data/catalog.yaml"] do
	@required_courses ||= YAML.load_file('data/required_courses.yaml')
	@catalog          ||= SummerResearch::Catalog.load("data/catalog")
	
	# =====
	
	puts "Filtering courses..."
	filtered_list = 
		@required_courses.reject{  |course| course.id == "Mason Core" }
		                 .uniq{  |a| a.id    }
		                 .sort_by{  |a| a.id.split(' ').first   }
	
	puts "=== recursive download of dependencies... "
	
	
	
	
	# recursive traversal
	# (iterative implementation, breadth first traversal)
	
	# maybe try a depth first approach this time?
	# maybe that would make it easier to report errors with proper context?
	
	input_list = filtered_list.collect{  |cat_link| cat_link.id  }.uniq
	
	all_info_pages = Array.new
	
	# input_list     - array of strings, ex) ["CS 101", "CS 330", "CS 499"]
	# all_info_pages - collection of CourseInfo objects (should all be unique)
		# NOTE: equality of CourseInfo objects within a Set not yet defined
	until input_list.empty? do
		info_pages = 
			input_list.collect do |course_id|
				info = nil
				begin
					info = @catalog.download_course_info(course_id)
				rescue StandardError => e
					
				ensure
					yield info
				end
				
				
				info
			end
		
		nested_ids = info_pages.collect{  |info| SummerResearch.list_dependencies(info)  }
			# [[id, id, id], [id, id]]
		
		# add recently downloaded data into the greater collection (in-memory cache)
		all_info_pages += info_pages
		
		# all dependencies at this level
		new_dependencies = nested_ids.flatten.compact.uniq
			# [id, id, id, id]
		
		# all dependencies where data has not yet been fetched
		dep_set           = new_dependencies.to_set                           # set of strings
		detailed_info_set = all_info_pages.collect{  |info| info.id  }.to_set # set of strings
		new_deps          = dep_set.difference(detailed_info_set)
		
		# fetch new specific data
		input_list = new_deps.to_a
	end
	# TODO: like other testing, alert when there is an error with parsing dependencies for a course, but continue on to the other courses. I would like to be able to see some trends in anamolous data.
	
	
	
	SummerResearch::Utilities.write_to_file("./all_course_data.yaml", all_info_pages.to_yaml)
	@full_dependency_list = all_info_pages
end



# extract data from programs of study for manual generation of graphs.
# Just want to pull down the basic info I'm going to need to get this stuff done.
# Don't want to attempt to fully automate any more, because the data is too messed up.
# 
# Tests for various errors that may occur while trying to look up a course in the catalog by ID
task :new_pathway5 => ["data/programs_of_study.yaml", "data/catalog.yaml"] do
	puts "=== load data..."
	
	@programs_of_study ||= YAML.load_file("data/programs_of_study.yaml")
	@catalog           ||= SummerResearch::Catalog.load("data/catalog")
	
	# ===
	
	puts "=== Get degree requirements..."
	
	programs = [
		"Computer Science, BS",
		"Applied Computer Science, BS",
		"Biology, BA",
		"Biology, BS",
		"Psychology, BA"
	]
	
	out = 
		programs.collect do |program_name|
			verbose = false
			
			puts "=== #{program_name}"
			# === take one degree program, and walk the dependencies for all courses in the degree
			# (get all relevant courses)
			
			url = @programs_of_study[program_name]
			
			fragment = SummerResearch.requirements_subtree(url)
			
			# TODO: need to improve this selector. catching some false positives.
			# wait, variable 'fragment' is a list...
			course_list = SummerResearch.get_all_weird_link_urls(fragment)
			
			puts "Filtering courses..."
			better_list = 
				course_list.reject{  |course| course.id == "Mason Core" }
				           .uniq{  |a| a.id    }
				           .sort_by{  |a| a.id.split(' ').first   }
			# NOTE:
				# "Mason Core" -> the whole thing, not one particular course class, causes crash
				# "BIOL 580" -> no data on BIOL classes > 499 (pagination problem)
				
				# leading space
				# BIOL > 499
				# Mason Core
				# numbers only, no department (Psych BA)
				
				
			puts "Downloading data..."
			
			data = 
				better_list.collect do |catalog_link|
					print '.'
					
					begin
						@catalog.download_course_info(catalog_link.id)
					rescue StandardError => e
						# from foo11
						puts
						puts e.message
						
						if verbose
							e.backtrace.each do |line|
								puts "\t" + line
								# indent the lines of the backtrace.
								# makes it easier to see things when you start getting multiple errors
							end
						end
					end
				end
			puts ""
			
			data
		end
	
	SummerResearch::Utilities.write_to_file("./all_degree_requirements.yaml", out.to_yaml)
end


































































def mongo_environment()
	# how to start and run MongoDB:
	# https://docs.mongodb.com/manual/tutorial/manage-mongodb-processes/
	
	mongo_db_storage_path = File.expand_path("bin/data/mongo",          PATH_TO_ROOT)
	mongo_db_logfile      = File.expand_path("bin/data/mongo_logs/log", PATH_TO_ROOT)
	
	p mongo_db_storage_path
	mongo_command = 
		"mongod --dbpath '#{mongo_db_storage_path}' --port 12345 --fork --logpath '#{mongo_db_logfile}'"
	
	# launch mongo as a daemon
		# mongod --fork --logpath /var/log/mongodb.log
	`#{mongo_command}`
	
	# run whatever needs to get done while mongo is up
	yield
	
	# stop mongo
	# (needs to know just the dbpath so it knows what DB to stop, but may as well pass everything)
	`#{mongo_command} --shutdown`
end


SQLITE_DATABASE_FILEPATH = 'example.db'

namespace :db_backend do
	task :create_db do
		mongo_environment do
			@catalog = Catalog.new(SQLITE_DATABASE_FILEPATH)
				# connect to the SQLite and MongoDB databases
				
			@catalog.setup
				# establish the schema
			@catalog.fetch_course_listing
				# download list of possible catalog years
				# figure out how to search by dept code for each and every catalog year
				# get lists of courses, based on a subset of dept codes, for each and every year
		end
	end
	
	# file SQLITE_DATABASE_FILEPATH do
	# 	Rake::Task["db_backend:create_db"].invoke
	# end
	
	# run 'create_db' before this to download initial data
	# (can't list as explict dependency at this time, because I don't know how to easily skip processing and entire catalog year)
	task :query_db do
		mongo_environment do
			@catalog = Catalog.new(SQLITE_DATABASE_FILEPATH)
			
			
			info = @catalog.course_info('CS 101')
			p info
			# @catalog.query do |q|
				
			# end
		end
	end
	
	task :wipe_mongo do
		mongo_environment do
			@catalog = Catalog.new(SQLITE_DATABASE_FILEPATH)
			
			@catalog.course_details_mongo do |db|
				result = db.delete_many
				puts result.n
			end
		end
	end
	
	
	
	
	
	
	
	
	file 'data/programs_of_study.yaml' do
		puts "=== setup data"
		# search for relevant programs of study
		
		list_of_degrees = [
			"Computer Science",
			"Information Technology",
			"Electrical Engineering",
			"Biology",
			"Psychology"
		]
		
		degrees = SummerResearch.search_programs_of_study(list_of_degrees)
		
		
		count = degrees.keys.size
		puts "#{count} programs found for search query."
		
		SummerResearch::Utilities.write_to_file("./programs_of_study.yaml", degrees.to_yaml)
		@programs_of_study = degrees
	end
	
	
	# List all the courses required for one particular program of study.
	# Currently not a very advanced procedure, just grabs all of the links on the page.
	# (modern equavialent of foo2)
	file 'data/required_courses.yaml' => 'data/programs_of_study.yaml' do
		@programs_of_study ||= YAML.load_file("data/programs_of_study.yaml")
		
		
		# TODO: output data on different degrees to different folders.
		# probably need to restructure some other code, such that the output directory is configurable?
		
		[
			"Computer Science, BS",
			"Applied Computer Science, BS",
			"Biology, BA",
			"Biology, BS",
			"Psychology, BA"
		]
		
		
		program_name = "Computer Science, BS"
		url = @programs_of_study[program_name]
		course_list = all_courses_for_degree(url)
		
		# TODO: remove dupicate entries in the list of courses
			# not just as simple as removing duplicates from list
			# need to remove when two tuples have the same first element
			# also - want to keep original ordering
		# NOTE: this may not be necessary if the selection filter on links is improved
		
		SummerResearch::Utilities.write_to_file("./required_courses.yaml", course_list.to_yaml)
		
		@required_courses = course_list
	end
	
	task :cs_requirements => 'data/required_courses.yaml' do
		@required_courses ||= YAML.load_file('data/required_courses.yaml')
		
		
		mongo_environment do
		
		@catalog = Catalog.new(SQLITE_DATABASE_FILEPATH)
		
		
		
		# filter out the main Mason Core page. This is not a class, but an overview of the entire core curriculum
		
		main_requirements = 
			@required_courses
			.reject{|catalog_link| catalog_link.id == "Mason Core"}
			.collect do |catalog_link|
				id = catalog_link.id
				
				puts "============"
				p id
				data = @catalog.course_info(id)
				p data
				
				data
			end
			
			
			
			
			
			
			puts "Filtering courses..."
			better_list = 
				course_list.reject{  |course| course.id == "Mason Core" }
				           .uniq{  |a| a.id    }
				           .sort_by{  |a| a.id.split(' ').first   }

		
		
		main_requirements.each do |course|
			
			puts course.id
			get_dependencies(course)
			
			
			
			# "math placement test"
			# "Placement Test"
			# "Mathematics Placement Test"
			
			# "algebra tutorial program"
			
			
			
			
			# HNRS 122, 130, 131, 230 or 240
			# CS 262 or 222
			# ECE 301 or 331
			# CS 310, 330, and 367
			# "Grade of C or better in CS 310, 330, and 367."
			# MATH 123 and 124
			# "C or better in MATH 113 or in both MATH 123 and 124."
			
			
			
			
			# "Completion of 45 credits including the Mason core composition and literature requirements, requires a grade of C or better."
			# => ["of 45"]
			
			# "Score of 13 or better on the Math Placement Test, or Grade of C or better in MATH 105, or Grade of C or better in MATH 108, or Grade of C or better in MATH 113."
			# => ["of 13", "MATH 105", "MATH 108", "MATH 113"]
			
			# "C or higher in STAT 346 and a course in Statistics, or STAT 344."
			# "a course in Statistics" ???
				# ACS Gaming specifies that you can take "344 or a course in statistics relevant to your major" [paraphrased] so I have seen precedience for this sort of loose dependency around stat.
				# (but IIRC there aren't currently any courses like that offered at Mason? so why is there this stipulation at all? future-proofing?)
				# 
				# (future-proofing is a cool backend-y sort of thing, but it's weird for that to be exposed to students / other end users)
		end
		
		
		end
	end
	
	
	
	
	task :get_info do
		mongo_environment do
			@catalog = Catalog.new(SQLITE_DATABASE_FILEPATH)
			p @catalog.course_info("STAT 344")
		end
	end
	
	
	
	
	
	
	# ==================
	# v  tests, based on old pathways
	
	
	# === test conversion of CatalogLink object => CourseInfo object
	# (used for fetching detailed information on a specific course from the catalog)
	# (currently does not interface with MongoDB at all, so no caching of any sort is performed)
	# 
	# There are currently 3 different major types of document pages stored in the online catalog
	# CourseInfo should be able to parse all of the differnt variations.
	# These tests throw a considerable variety of data at CourseInfo, and print diagonstics.
	# 
	# Viewing the diagnostic outputs from these tasks should help a person see
	# how the system currently is classifying these documents.
	# (NOTE: this is a manually designed and implemented classification, not machine learning)
	task :pw_sample_data do
		# NOTE: easily get data for this table from the intermediate file required_courses.csv
		# (UPDATE: need to figure out a similarly easy way to rip this data out from the DB)
		sample = [
			[
				"CS 101",
				"Preview of Computer Science",
				"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302776&print"
			],
			[
				"CS 465",
				"Computer Systems Architecture",
				"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302800&print"
			],
			[
				"CS 475",
				"Concurrent and Distributed Systems",
				"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302803&print"
			],
			[
				"EVPP 110",
				"The Ecosphere: An Introduction to Environmental Science I",
				"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=303982&print"
			],
			[
				"Mason Core UGU",
				"Global Understanding",
				"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=308635"
			]
		].collect{|a,b,c| SummerResearch::CatalogLink.new(a, b, c, 'manual') }
		
		@pw_sample = sample
	end
	
	
	
	
	# course [CatalogLink] => [CourseInfo] RELEASE VERSION
	# no debug information. just prints the course ids for the classes being downloaded
	# (input dataset: all courses from CS degree)
	task :pw5 => "data/programs_of_study.yaml" do
		@programs_of_study ||= YAML.load_file("data/programs_of_study.yaml")
		
		mongo_environment do
			@catalog = Catalog.new(SQLITE_DATABASE_FILEPATH)
			
			
			
			programs = [
				"Computer Science, BS",
				"Applied Computer Science, BS",
				"Biology, BA",
				"Biology, BS",
				"Psychology, BA"
			]
			
			program_name = "Computer Science, BS"
			url = @programs_of_study[program_name]
			courses = all_courses_for_degree(url)
			
			
			
			
			puts "=== run processing"
			course_data = SummerResearch::Main.foo13(@catalog, courses) # course [CatalogLink] => [CourseInfo] RELEASE VERSION
			
			Utilities.write_to_file('./course_info.yaml', course_data.to_yaml)
		end
	end
	
	# [CatalogLink] => [CourseInfo] DEBUG
	# only shows error messages when the system fails to fetch a page
	# otherwise just prints dots to let you know progress is happening
	# allows you to see errors across all entries (does not stop after the first error)
	# 
	# (input dataset: sample dataset)
	task :pw6 => [:pw_sample_data] do
		mongo_environment do
			@catalog = Catalog.new(SQLITE_DATABASE_FILEPATH)
			
			puts "=== run processing"
			
			@pw_sample                           # sample data set => [CatalogLink] 
			course_data = SummerResearch::Main.foo11(@catalog, @pw_sample) # [CatalogLink] => [CourseInfo] DEBUG
		end
	end
	
	# [CatalogLink] => [CourseInfo] DEBUG VERBOSE
	# prints extensive information on the types of data being detected.
	# type signatures and debug information displayed for all entries.
	# allows you to see errors across all entries (does not stop after the first error)
	# 
	# (input dataset: sample dataset)
	task :pw8 => [:pw_sample_data] do
		mongo_environment do
			@catalog = Catalog.new(SQLITE_DATABASE_FILEPATH)
			
			puts "=== run processing"
			
			@pw_sample                           # sample data set => [CatalogLink] 
			course_data = SummerResearch::Main.foo14(@catalog, @pw_sample) # [CatalogLink] => [CourseInfo] DEBUG VERBOSE
		end
	end
	
	# [CatalogLink] => [CourseInfo] DEBUG
	# (input dataset: ALL courses from ALL majors in the sample set)
	# 
	# same core procedure as pw6, but with a much bigger data set
	task :pw7 do
		mongo_environment do
			@catalog = Catalog.new(SQLITE_DATABASE_FILEPATH)
			
			puts "=== load data..."
			@programs_of_study ||= YAML.load_file("data/programs_of_study.yaml")
			
			
			puts "=== cycle through programs of study..."
			
			programs = [
				"Computer Science, BS",
				"Applied Computer Science, BS",
				"Biology, BA",
				"Biology, BS",
				"Psychology, BA"
			]
			programs.each do |degree_name|
				puts "=== Getting info for: #{degree_name}"
				url = @programs_of_study[program_name]
				courses = all_courses_for_degree(url)
				# If the program list has a weird link in it, then the foo2 will fail before reaching the end of the list
					# url = @env.degrees[degree_name]
					# course_list = SummerResearch.degree_requirements(url)
					# puts "test"
				# failure occurs inside of SummerResearch.degree_requiremnts
				
				puts "=== analyzing courses... "
				course_data = SummerResearch::Main.foo11(@catalog, courses)
			end
			
			# errors from: SummerResearch::CourseInfo#fetch
			# two other page formats:
				# +  new page format: attemps to give more structure using <p> to separate into sub-regions, but actually malformed
					# ^ seems to be for more recent courses? not really sure why the markup is different
				# +  Mason Core pages: Totally different pages, because these are not actually courses. They are "aliases" of sorts for entire lists of courses.
			
			
			
			# NOTE: perhaps not all majors work right now? so be careful of that too
			
			
			
			# NOTE: the following programs of study only use Type A or Type B catalog links
				# "Computer Science, BS",
				# "Biology, BA",
			# NOTE: the following programs of study are known to list courses with Type C catalog links
				# "Applied Computer Science, BS",
				# "Biology, BS",
				# "Psychology, BA"
		end
	end
end


def get_dependencies(course_info)
	regexp = /(\p{L}+ \d+)/ # look for course codes in the requirements lists
	
	
	hard_deps =
	%w[Prerequisite(s) Corequisite(s)]
		.collect do |x|
			requirements = course_info[x]
			p requirements
			next unless requirements
			requirements.scan(regexp)
		end
		
	
	# "C or higher in CS 105; (COMM 100, and ENGH 302) or (HNRS 110 and HNRS 122, 130, 131, 230 or 240); junior standing (at least 60 credit hours)."
	# ERROR: can't deal with 'or 240'
	# ERROR: can't deal with 'at least 60 credit hours' => 'least 60'
	
	# "Grade of C or better in CS 310, 330, and 367."
	# ERROR: can't deal with 'CS 310, 330, and 367' => 'and 367'
	
	# CS 499 
	# Prerequisite(s): 60 credits and permission of instructor; specific prerequisites vary with nature of topic.
	
	# PHIL 371 - Philosophy of Natural Sciences
	# Prerequisite(s): "3 credits of philosophy, or permission of instructor"
	
	
	
	
	# SWE 443 - Software Architectures
	# Prerequisite(s): Grade of C or better in CS 321 or CS 421 or SWE 321 or SWE 421.
	# IIRC, 421 was re-numbered to 321.
	# Notice that the numbers are the same for CS and SWE
	# this is a cross-listed course.
		# (note that some cross listed courses are exactly the same, but there's some OR course that's not? depending on if you take it as OR or MATH, there are a different number of seats avaiable in the class, and the prereqs are fairly different. This is despite it being the exact same physical lecture section.)
	
	
	
	
	# "#{course} with grade of C or better"
	# "Minimum grade of C in #{course}"
	soft_deps = 
		if course_info["Notes"]
			# [0] PHYS 161
			# [1] PHYS
			# [2] 161
			
			# soft_deps = course_info["Notes"].scan(regexp).collect{ |matches| matches[0] }
			[] # pseudo-return empty array to stub this out
		else
			[] # if "Notes" attribute not set, return empty Array
		end
	
	
	# p hard_deps
	# p soft_deps
	dependencies = hard_deps + soft_deps
	
	
	p dependencies.flatten.compact.uniq
	puts "---------"
end



# =====
puts "Filtering courses..."
better_list = 
	course_list.reject{  |course| course.id == "Mason Core" }
	           .uniq{  |a| a.id    }
	           .sort_by{  |a| a.id.split(' ').first   }


# TODO: print list of courses for a degree, chunked by what sector they appear in in the Program of Study page. This, in conjunction with the dependency info printed in pathway10, can be used to generate visualizations.







def all_courses_for_degree(url_to_program_requirements_page)
	puts "=== run processing"
	
	# === take one degree program, and walk the dependencies for all courses in the degree
	# (get all relevant courses)
	
	fragment = SummerResearch.requirements_subtree(url_to_program_requirements_page)
	
	# TODO: need to improve this selector. catching some false positives.
	# wait, variable 'fragment' is a list...
	course_list = SummerResearch.get_all_weird_link_urls(fragment)
	
	return course_list
end













# this is just a template
# 1 2 3 (list the full foo execution chain?)
task :pathwayX do
	
end


