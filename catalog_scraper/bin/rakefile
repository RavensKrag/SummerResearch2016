#!/usr/bin/env ruby
# encoding: utf-8

# gems
require 'rubygems'

require 'rake'
require 'rake/clean'

require 'bundler/setup'
require 'require_all'

# constants
PATH_TO_FILE = File.expand_path(File.dirname(__FILE__))

# -- file hierarchy --
		# ROOT
		# 	this directory
		# 		this file

# Must expand '..' shortcut into a proper path. But that results in a shorter string.
PATH_TO_ROOT = File.expand_path '../..', __FILE__





















module SummerResearch


DATA_DIR = File.join(PATH_TO_ROOT, 'bin', 'data')

CatalogLink = Struct.new("CatalogLink", :id, :description, :url, :link_type)




def degree_requirements(url)
	fragment = requirements_subtree(url)
	
	out = 
	fragment.collect do |node|
		# puts node.class
		# onclick_scripts = node.xpath('.//a[@onclick]').collect{  |link| link['onclick']  }
		# onclick_scripts.each do |script|
		# end
		
		get_all_weird_link_urls(node)
	end
	
	return out.flatten
end

def requirements_subtree(url)
	xml = Nokogiri::HTML(open(url))
	
	top        = xml.css('table.block_n2_and_content')
	main_table = top.css('td.block_content_outer')
		Utilities.write_to_file("./ruby_test.html", main_table)
	
	
	
	
	title       = main_table.css('h1#acalog-content').inner_html
	banner_code = main_table.css('td.block_content p')[1].css('strong').inner_html

		h2 = main_table.css('td.block_content p')[2]
		links = h2.css('a')
		links[1]
	
	school      = links[0]
	department  = links[1]
	description = h2
	
	# WARNING: mixed content. No good way to just grab the description.
		# Degree name
		# banner code
		# school
		# department
		# description
	# are all at the same level of the tree.
	
	description_container = main_table.css('td.block_content > table tr')[0]
		# contains sections described in comment above
	
	
	requirements = main_table.css('td.block_content > table tr > td')[3]
		# should contain the actual course info
		Utilities.write_to_file("./requirements.html", requirements.inner_html)
		
		# outer div with a bunch of divs inside it
			# requirements
			# total number of credits
			# honors program
			# change of major
			# etc
	
	
	# when examining the CS requriments: (seems to work for both CS and ACS)
	# a.children[0] # header
	# a.children[1] # main requirements (many divs inside here that break doc into sections)
	# a.children[2] # total number of credits
	
	# a.children[3] # each div from here on out has an h2 element with a title, and some text
	
	
	# in the main div list:
		# .acalog-core is the main stuff
		# the other ones with inline style "padding-left: 20px" are notes etc
	
	
	
	# ok, to list this in a more robust way:
	# h2: "Degree Requirements"
	# * 
	# * one or more divs and their subcontainers that list course requirements
	# * (probably want to keep this tree-like structure)
	# * 
	# h2: line listing the total number of credits (CS says "Total: " Bio BA says "Degree Total: ")
	# * zero or more extra sections listing additional notes etc
	
	
	
	
	# === get the section between the header and the number of credits
	
	# requirements.css('div').size
	# puts requirements.children.size
	
	# requirements.children => [some whitespace at top of file, outer div]
	# css: outer div > actual content
	list = requirements.children[1].children
	# puts list.size
	
	# list.each_with_index do |node, i|
	# 	puts node.class
		
	# 	if node.inner_text.include? "Degree Requirements"
	# 		puts "start: #{i}"
	# 	elsif node.inner_text.include? "Total:"
	# 		puts "end: #{i}"
	# 	end
	# end
	
	i_start = list.find_index{  |x| x.inner_text.include? "Degree Requirements" }
	i_end   = list.find_index{  |x| x.inner_text.include? "Total:" }
	
	
	fragment = list[i_start..i_end]
		Utilities.write_to_file("./fragment.html", fragment)
	
	return fragment
	
	
	# different end markers for different departments
	# (note that Psych BA uses "Total: " to show subtotals)
	# Really want to check for the substrings "Total:" and "120 credits"
	
	# program     target end string                     range
	# -------     -------------------                   ------
	# CS BS       "Total: 120 credits"                  (0..2)
	# Bio BA      "Degree Total: Minimum 120 credits"   (0..5)
	# Psych BA    "Degree Total: Minimum 120 credits"   (?..?)
	
	# NOTE: section headings for "Mason Core" and "BA Requirements" may vary
end



def get_all_weird_link_urls(node)
	# ------
	node.xpath('.//a[@onclick]')
	    .collect{  |link_node|  unpack_catalog_link(link_node)  }
	# ------
end

def unpack_catalog_link(node)
	text = node.inner_text
	text.gsub!(" - ", " - ") # replace em-dash (long one) with en-dash (ASCII)
	
	id, description = text.split(" - ")
	
	url, link_type = extract_link(node['onclick'])
	
	
	return CatalogLink.new(id, description, url, link_type)
end

def extract_link(script)
	# TEST: checks to see that either one match or the other is found, but not both
	# puts script.scan(regexp_a).size + script.scan(regexp_b).size == 1
		
	patterns = {
		"Type A" => {
			:pattern  => /showCourse\('(.+?)'\, '(.+?)',this,/,
			:callback => ->(matches){
				all, a,b = matches.to_a
				"preview_course.php?catoid=#{a}&coid=#{b}&print"
			}
		},
		
		"Type B" => {
			:pattern  => /acalogPopup\('(.+?)'.*/,
			:callback => ->(matches){
				matches[1]
			}
		},
		
		"Type C" => {
			:pattern  => /showCatalogData\('(\d+?)'\, '(\d+?)'\, '(\d+?)'\, '(.+?)'/,
			:callback => ->(matches){
				all, a,b,c,d = matches.to_a
				# p [a,b,c,d]
				"preview_course.php?catoid=#{a}&coid=#{c}&print"
			}
		}
	}
	
	name_url_pairs = 
		patterns.lazy
		        .collect{  |type, data|   [type, script.match(data[:pattern]), data[:callback]]  }
		        .reject{   |type, match, callback|  match.nil?  }
		        .collect{  |type, match, callback|  [type, callback[match]]  }
		        .to_a
	
	name_url_pairs.size == 1
	
	# TODO: remove '&print' from URLs, so if you every have to view the page manually for debugging etc, you get the nice looking UI, and not the print-friendly UI.
	# (I've been just removing that bit manually, but that seems a bit silly.)
	
	unless name_url_pairs.size == 1
		puts "==== Data Dump ===="
		puts "Script:"
		puts script
		puts "Regex Sets:"
		p name_url_pairs
		puts "==================="
		
		raise "Error: could not find catalog course link inside this script. See data dump above, or stack trace below."
	end
	
	# should only ever be one at this point
	type, local_link = name_url_pairs.first
	
	return "http://catalog.gmu.edu/" + local_link, type
end

def search_programs_of_study(url, target_fields)
	levels = %w[BS BA MS PhD MA]
	# TODO: limit degrees by education level
	
	
	# --- fetch the page from the internet
	# note: catoid encodes the catalog year
	xml = Nokogiri::HTML(open(url))
	
	puts "downloading list of all programs at Mason..."
	# --- grab unordered list from the HTML
	ul = xml.css('td.block_content_outer ul li')
	
	# --- get just the relevant string names, and the links to the requirements pages
	all_degrees = ul.collect do |x|
		# puts x.class
		# puts x.xpath('./a').first['href']
		# p x.inner_text # "• \nWomen and Gender Studies Minor"
		link = x.xpath('./a').first['href']
		text = x.inner_text[3..-1].strip # take the
		
			# benchmark of 'remove first few characters' approaches in Ruby
			# http://stackoverflow.com/questions/3614389/what-is-the-easiest-way-to-remove-the-first-character-from-a-string
		link = "http://catalog.gmu.edu/" + link
		
		[text, link]
	end
	
	puts "searching..."
	# --- convert associative array into a hash
	programs_of_study = all_degrees.to_h
	
	
	# --- select the degrees where one of the target fields is found as a substring
	selected_degrees = 
		programs_of_study.keys.select do |degree_name|
			# normalize
			x = degree_name.downcase
			y = target_fields.collect{|x| x.downcase }
			
			# perform actual selection
			if y.any?{  |q|  x.include? q    }
				true
			end
		end
	# puts selected_degrees
	
	
	# --- limit the outgoing hash to only the selected fields
	# (this way, you can use the size of the hash to see how many hits your query gets)
	programs_of_study.delete_if{  |key| not selected_degrees.include? key }
		# TODO: consider using a set to speed up #include?
	
	# puts "===================="
	
		
	return programs_of_study
end

# get a list of classes using the catalog search
# ex) "BIOL", "CS", etc
# returns a list of triples: dept_code, class_number, url
#                       ex) [CHEM, 313, catalog_URL_here]
def courses_in_department(dept_code)
	# use this url to search for courses
	# may return mulitple pages of results, but should be pretty clear
	url = "http://catalog.gmu.edu/content.php?filter%5B27%5D=" + dept_code + "&filter%5B29%5D=&filter%5Bcourse_type%5D=-1&filter%5Bkeyword%5D=&filter%5B32%5D=1&filter%5Bcpage%5D=1&cur_cat_oid=29&expand=&navoid=6272&search_database=Filter#acalog_template_course_filter"
	
	xml = Nokogiri::HTML(open(url))
	
	puts "searching for classes under: " + dept_code + " ..."
	
	node = xml.css('td.block_content_outer table')[3]
		Utilities.write_to_file("./search.html", node)
	
	tr_list = node.css('tr')[2..-1]
	
	# tr_list.each{|x| puts x.class }
	return tr_list.collect{  |x| get_all_weird_link_urls(x)  }.flatten
end






# this is basically a pathway.
# 
# dependencies: foo1
# get the list of courses for one program, based on its name
def foo2(degree_name)
	url = @degrees[degree_name]
	# url = self.degree_dict["Applied Computer Science, BS"]
	# url = self.degree_dict["Biology, BA"]
	# url = self.degree_dict["Biology, BS"]
	# url = self.degree_dict["Psychology, BA"]
	
	course_list = degree_requirements(url)
	# puts course_list.to_yaml
	
	# TODO: remove dupicate entries in the list of courses
		# not just as simple as removing duplicates from list
		# need to remove when two tuples have the same first element
		# also - want to keep original ordering
	# NOTE: this may not be necessary if the selection filter on links is improved
	
	
	Utilities.write_csv('./required_courses.csv', course_list)
	
	# arr_of_arrs = CSV.parse("CSV,data,String")
	
	return course_list
end



# this is a very simple routine. does not need to be it's own function

# similar to the tests (very similar to foo12),
# but this is an actual procedure
# (subroutine. used to generate intermediates. should probably parameterize output path?
# (or maybe just return data, and not write to file)
def foo13(course_list)
	output_data = 
		course_list.collect do |course|
			puts course.id
			SummerResearch::CourseInfo.new(course).fetch
		end
	# p output_data
	Utilities.write_to_file('./course_info.yaml', output_data.to_yaml)
	
	return output_data
end




# private



# dependencies: foo5
# precursor: foo4
# course ID = DEPT ### (ex: CHEM 313)
def get_info(course_id)
	# dept, number = course_id.split()
	
	# @course_dict[dept].find{|x| x.include? number }
	# course_page = next(x[2] for x in @course_dict[dept] if number in x[0])
	# return util.course_info(course_page)
end


end




task :load_dependencies do
	# gems
	require 'open-uri'
	require 'nokogiri'
	require 'yaml'
	require 'csv'
	
	# files
	Dir.chdir PATH_TO_ROOT do
		require_all './lib/SummerResearch'
	end
end

task :load_main do
	# require './main'
end


task :default => :run

# run the program
task :run => [:setup] do
	p @env
	# consider different forms of caching
	# -- instance variable: cache for the session
	# -- save to disk: cache for multiple sessions
	
	# TODO: consider promoting pathway4 as the default?
end

# all root tasks should list this as a dependency
task :setup => [:load_dependencies, :load_main] do
	puts "=== setup environment"
	@env = SummerResearch::Main.new
end

task :all => [
	:pathway1,
	:pathway2,
	:pathway3,
	:pathway4,
	:pathway5,
	:pathway6,
	:pathway8,
	:pathway7
]





# 1
task :pathwayA => :setup do
	puts "=== setup data"
	# search for relevant programs of study
	# (required to run #foo2)
	@env.foo1 [
		"Computer Science",
		"Information Technology",
		"Electrical Engineering",
		"Biology",
		"Psychology"
	]
end

# 5
task :pathwayB => :setup do
	# search catalog for even more data?
	deparments = ["CS", "BIOL", "CHEM", "PSYC"]
	@env.foo5(deparments)
end



# 1 2 3
task :pathway1 => :pathwayA do
	courses = @env.foo2("Computer Science, BS")
	
	@env.foo3()
	
	#  1  load degrees
	#  2  get courses from CS degree
	#  3  test certain classes, to make sure they parse (DEPRECIATE FUNCTION)
end

# 5 4
task :pathway2 => :setup do
	@env.foo5(["CS"])	
	@env.foo4()
	
	#  5  load courses by department code
	#  4  pick out a specific course by ID, fetch that data using CourseInfo object
end

# 1 6
task :pathway3 => :pathwayA do
	@env.foo6() # NOTE: foo6 not yet properly ported
	
	#  1  load degrees
	#  6  get full program requirements logic (more than just course dependencies)
end

# 1 5 7 8 10 9
task :pathway4 => [:pathwayA, :pathwayB] do
	#  1  load degrees
	#  5  load courses by department code
	#  7  scrape all links from overview of one degree. no degree requenments, just a dumb list.
	#  8  Backend dependency graph construction.
	# 10  visualization of graph
	#  9  queries on the graph
	 
	
	# TODO: cache 1 and 5 to speed up evaluation
	
	
	
	puts "=== run processing"
	
	[
		"Computer Science, BS",
		"Applied Computer Science, BS",
		"Biology, BA",
		"Biology, BS",
		"Psychology, BA"
	]
	
	# take one degree program, and walk the dependencies for all courses in the degree
	course_list = @env.foo7("Computer Science, BS")  # get all relevant courses
	class_dependencies = @env.foo8(course_list)      # construct all dependencies
	
	output_filepath = ""
	@env.foo10(class_dependencies, output_filepath)  # visualize the dependency graph
	
	
	# query: what is the chain of courses that lead up to this course? 
	@env.foo9(class_dependencies, "CS 465")
	# => [CS 367, ECE 301, CS 262, CS 211, CS 112, MATH 113, CS 101?]
	
	# TODO: This is actually not properly a list, it is a subgraph. Some dependencies do not lie along the main path. How do you display that information?
	# NOTE: "ECE 301" is the old name, IIRC
end

# 1 2 13
task :pathway5 => :pathwayA do
	#  1  load degrees
	#  2  get courses from CS degree
	# 13  fetch all courses in list, and write data to file (also return) (input: course structs)
	
	courses = @env.foo2("Computer Science, BS")
	
	
	puts "=== run processing"
	course_data = @env.foo13(courses)
end

# test course parsing with a couple of key examples
# (TODO: take extra data from foo3 and move into foo12 for more variety of data)
# 1 2 12 11
task :pathway6 => :pathwayA do
	#  1  load degrees
	#  2  get courses from CS degree
	# 12  encode sample course data as CatalogLink structs
	# 11  try to fetch data for courses listed. light debug info. can quickly indenitfy problems.
	
	courses = @env.foo2("Computer Science, BS")
	
	
	puts "=== run processing"
	
	courses = @env.foo12()
	course_data = @env.foo11(courses)
end

# test course parsing with a couple of key examples
# Test for different types of course description pages
# 1 2 12 14
task :pathway8 => :pathwayA do
	#  1  load degrees
	#  2  get courses from CS degree
	# 12  encode sample course data as CatalogLink structs
	# 14  try to fetch data for courses listed. verbose debug mode. basically everything you need.
	
	courses = @env.foo2("Computer Science, BS")
	
	
	puts "=== run processing"
	
	courses = @env.foo12()
	course_data = @env.foo14(courses)
end

# test all courses across various majors to make sure everything runs correctly
# uses foo11 to detect which courses have odd link formats
# 1 2 11
task :pathway7 => :pathwayA do	
	#  1  load degrees
	#  2  get courses from CS degree
	# 11  try to fetch data for courses listed. light debug info. can quickly indenitfy problems.
	
	puts "=== cycle through programs of study..."
	
	programs = [
		"Computer Science, BS",
		"Applied Computer Science, BS",
		"Biology, BA",
		"Biology, BS",
		"Psychology, BA"
	]
	programs.each do |degree_name|
		puts "=== Getting info for: #{degree_name}"
		courses = @env.foo2(degree_name)
		# If the program list has a weird link in it, then the foo2 will fail before reaching the end of the list
			# url = @env.degrees[degree_name]
			# course_list = degree_requirements(url)
			# puts "test"
		# failure occurs inside of degree_requiremnts
		
		puts "=== analyzing courses... "
		course_data = @env.foo11(courses)
	end
	
	# errors from: SummerResearch::CourseInfo#fetch
	# two other page formats:
		# +  new page format: attemps to give more structure using <p> to separate into sub-regions, but actually malformed
			# ^ seems to be for more recent courses? not really sure why the markup is different
		# +  Mason Core pages: Totally different pages, because these are not actually courses. They are "aliases" of sorts for entire lists of courses.
	
	
	
	# NOTE: perhaps not all majors work right now? so be careful of that too
	
	
	
	# NOTE: the following programs of study only use Type A or Type B catalog links
		# "Computer Science, BS",
		# "Biology, BA",
	# NOTE: the following programs of study are known to list courses with Type C catalog links
		# "Applied Computer Science, BS",
		# "Biology, BS",
		# "Psychology, BA"
end


# Now that we have the data, actually start to walk it and do something interesting with it.
# (actually, may want to just go back to pathway4 instead)
# precedesssor: pathway4
# 1 5 7 8
task :pathway9 => [:pathwayA, :pathwayB] do
	#  1  load degrees
	#  5  load courses by department code
	#  7  scrape all links from overview of one degree. no degree requenments, just a dumb list.
	#  8  Backend dependency graph construction.
	
	
	# TODO: cache 1 and 5 to speed up evaluation
	
	
	puts "=== run processing"
	
	
	# TODO: output data on different degrees to different folders.
	# probably need to restructure some other code, such that the output directory is configurable?
	
	[
		"Computer Science, BS",
		"Applied Computer Science, BS",
		"Biology, BA",
		"Biology, BS",
		"Psychology, BA"
	]
	
	# take one degree program, and walk the dependencies for all courses in the degree
	course_list = @env.foo7("Computer Science, BS")  # get all relevant courses
	class_dependencies = @env.foo8(course_list)      # construct all dependencies
	
	puts "============"
	
	
	# =====
	puts "Filtering courses..."
	better_list = 
		course_list.reject{  |course| course.id == "Mason Core" }
		           .uniq{  |a| a.id    }
		           .sort_by{  |a| a.id.split(' ').first   }
	
	puts "=== download individual course data..."
	course_info_list = better_list.collect do |x|
		print '.'
		SummerResearch::CourseInfo.new(x).fetch
	end
	
	SummerResearch::Utilities.write_to_file("./all_course_data.yaml", course_info_list.to_yaml)
	
	# could pull down *list* of all courses associated with a dept
	# if courses in a major have prereqs in that department?
	# (definitely don't actually pull down each and every course before filtering though...)
	
	# under the current pipeline, I think this is the only way to do things?
	# can't ask for a single class by course ID until you have a list of all courses by dept
	# (foo4 experiments with this, but currently does not except a parameter)
	
	# department_codes = better_list.collect{ |course| course.id.split(' ').first }.uniq
end

# must run pathway9 before this, but can't list as explict dependency,
# because I want to be able to run pathway9 and pathway10 in separate executions
# (kinda like caching?)
task :pathway10 => :setup do
	# @env is active in this block, but can't actually be meaningully used
	# bascially, you should only interact with the data from the yaml file in this block,
	# otherwise weird things will happen
	
	# TODO: this code, when completed, should be moved under foo8
	
	course_info_list = SummerResearch::Utilities.load_yaml_file("./all_course_data.yaml")
	
	
	puts "=== process data..."
	course_info_list.each do |course_info|
		puts "#{course_info.id} - #{course_info.title}"
		
		regexp = /(\p{L}+ \d+)/
		
		# Explict dependencies
		
		
		hard_deps =
			%w[Prerequisite(s) Corequisite(s)]
				.collect do |x|
					requirements = course_info[x]
					p requirements
					next unless requirements
					requirements.scan(regexp)
				end
				
		
		# "C or higher in CS 105; (COMM 100, and ENGH 302) or (HNRS 110 and HNRS 122, 130, 131, 230 or 240); junior standing (at least 60 credit hours)."
		# ERROR: can't deal with 'or 240'
		# ERROR: can't deal with 'at least 60 credit hours' => 'least 60'
		
		# "Grade of C or better in CS 310, 330, and 367."
		# ERROR: can't deal with 'CS 310, 330, and 367' => 'and 367'
		
		# CS 499 
		# Prerequisite(s): 60 credits and permission of instructor; specific prerequisites vary with nature of topic.
		
		# PHIL 371 - Philosophy of Natural Sciences
		# Prerequisite(s): "3 credits of philosophy, or permission of instructor"
		
		
		
		# "#{course} with grade of C or better"
		# "Minimum grade of C in #{course}"
		soft_deps = 
			if course_info["Notes"]
				# [0] PHYS 161
				# [1] PHYS
				# [2] 161
				
				# soft_deps = course_info["Notes"].scan(regexp).collect{ |matches| matches[0] }
				[] # pseudo-return empty array to stub this out
			else
				[] # if "Notes" attribute not set, return empty Array
			end
		
		
		# p hard_deps
		# p soft_deps
		dependencies = hard_deps + soft_deps
		
		
		p dependencies.flatten.compact.uniq
		puts "---------"
	end
end

# TODO: print list of courses for a degree, chunked by what sector they appear in in the Program of Study page. This, in conjunction with the dependency info printed in pathway10, can be used to generate visualizations.

task :pathway11 => :setup do
	
end


# sketch new interface for doing these things
task :pathway12 => :setup do
	dataset1 = [
		"Computer Science, BS",
		"Applied Computer Science, BS",
		"Biology, BA",
		"Biology, BS",
		"Psychology, BA"
	]
	
	
	# Test course_info on various URLs with different sorts of attributes
	# NOTE: not all courses specify all attributes. 
	#   ex) If there are no corequisites, the field is omitted
	dataset2 = [
		["CS 330",   "http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302788&print"],
		["STAT 344", "http://catalog.gmu.edu/preview_course.php?catoid=29&coid=306778&print"],
		["PSYC 320", "http://catalog.gmu.edu/preview_course.php?catoid=29&coid=306130&print"]
	]
	
	
	dataset3 = [
		[
			"CS 101",
			"Preview of Computer Science",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302776&print"
		],
		[
			"CS 465",
			"Computer Systems Architecture",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302800&print"
		],
		[
			"CS 475",
			"Concurrent and Distributed Systems",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302803&print"
		],
		[
			"EVPP 110",
			"The Ecosphere: An Introduction to Environmental Science I",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=303982&print"
		],
		[
			"Mason Core UGU",
			"Global Understanding",
			"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=308635"
		]
	]
	
	
	foo1(list_of_degrees)
		url = "http://catalog.gmu.edu/content.php?catoid=29&navoid=6270"
		@degrees = search_programs_of_study(url, list_of_degrees)
		# ^ download the page that lists all possible programs of study, and filter for 
		# (returns hash: name => url)
		
		count = @degrees.keys.size
		puts "#{count} programs found for search query."
		
		filepath = File.expand_path("./programs_of_study.yaml", DATA_DIR)
		puts "Writing to file '#{filepath}'"
		
		File.open(filepath, 'w') do |f|
			f.puts @degrees.to_yaml
		end
	
	foo5(list_of_deparments)
		@courses = Hash.new
		
		list_of_deparments.each do |dept|
			@courses[dept] = courses_in_department(dept)
		end
	
	
	
	
	programs_of_study = scrape_catalog_for_degrees()
	programs_of_study["Computer Science, BS"]
	# ^ can get course links this way
	
	# search catalog for even more data?
	list_of_deparments = ["CS", "BIOL", "CHEM", "PSYC"]
	list_of_deparments.each do |dept|
		classes_in_dept = scrape_all_classes_from_department(dept)
	end
	# ^ can get course links this way
end






# this is just a template
# 1 2 3 (list the full foo execution chain?)
task :pathwayX => :setup do
	
end


