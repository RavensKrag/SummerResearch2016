# encoding: utf-8

require 'rubygems'

require 'rake'
require 'rake/clean'
require 'rake/testtask'

require 'bundler'
Bundler.require(:default)
require 'bundler/setup'

# other libraries
require 'yaml'
require 'csv'
require 'set'
require 'open-uri'


# constants
PATH_TO_FILE = File.expand_path(File.dirname(__FILE__))

# -- file hierarchy --
		# ROOT
		# 	this directory
		# 		this file

# Must expand '..' shortcut into a proper path. But that results in a shorter string.
PATH_TO_ROOT = File.expand_path '../..', __FILE__


# files
Dir.chdir PATH_TO_ROOT do
	require_all './lib/SummerResearch'
end



# setup tests
Rake::TestTask.new do |t|
	t.libs = []
	t.test_files = FileList['test/test*.rb']
	t.verbose = true
end

# task :default => :run











# Run multiple pathways with a single command
# usage: rake pathways[1,2,3]
# 
#           positional arguments only, no named args
#               V
task :pathways, [] => [:load_dependencies, :setup_data] do |t, args|
	pathway_numbers = args.extras.collect{|x| x.to_i }
	
	puts "pathways: #{pathway_numbers.inspect}"
	
	pathway_numbers.each do |number|
		Rake::Task["pathway#{number}".to_sym].invoke()
	end
end




# ok, this is pretty solid...
# but what happens when you get mulitple intermediates out of one process?
# (similar to a multiple return)


# Check out this question on StackOverflow that deals with this exact situation:
# src: http://stackoverflow.com/questions/24026092/rake-task-with-multiple-prerequisites-generating-multiple-outputs

# I modified that a little bit to write #multi_file()

# Declare a file task that generates mulitple files with the same prerequisites.
# (actually will generate multiple tasks, but this is a nice convienence)
def multi_file(args={}, &block)
	# kinda a hacky way of getting the Rake-style interface.
	# Should probably see what Rake actually does,
	# because this is not sophisticated enough to be how Rails works.
	outputs        = args.keys.first
	shared_prereqs = args.values.first
	
	outputs.each do |filename|
		file filename => shared_prereqs do |t|
			block.call(t)
		end
		# there should be a way to just pass the block, instead of calling a block from a block
		# but that way is complicated and arcane, so don't do it.
		# 
		# This way is simple to understand.
	end
end

# multi_file %w[target1.txt target2.txt] => %w[src1.txt src2.txt] do
	
# end





# =============================================





# could pull down *list* of all courses associated with a dept
# if courses in a major have prereqs in that department?
# (definitely don't actually pull down each and every course before filtering though...)

# under the current pipeline, I think this is the only way to do things?
# can't ask for a single class by course ID until you have a list of all courses by dept
# (foo4 experiments with this, but currently does not except a parameter)

# department_codes = better_list.collect{ |course| course.id.split(' ').first }.uniq



# ^ old way of doing things.
# The current implementation of Catalog first scans all years
# for a particular set of dept codes.
# 
# It will figure out what the urls are for all classes within this set,
# but refrain from downloading any specific course information
# until that particular class is requested.
# 
# It will cache data for specific courses in MongoDB,
# and save dept / id / url information in SQLite







# how to start and run MongoDB:
	# https://docs.mongodb.com/manual/tutorial/manage-mongodb-processes/
mongo_db_storage_path = File.expand_path("bin/data/mongo",          PATH_TO_ROOT)
mongo_db_logpath      = File.expand_path("bin/data/mongo_logs/log", PATH_TO_ROOT)

puts "========="
puts "Start up mongo in another terminal with the following command:"
puts "mongod --dbpath '#{mongo_db_storage_path}' --port 12345"

puts "and if necessary, mongo can be stopped with this command:"
puts "mongod --dbpath '#{mongo_db_storage_path}' --port 12345 --shutdown"
puts "========="
# (needs to know just the dbpath so it knows what DB to stop, but may as well pass everything)


# launch mongo as a daemon
		# mongod --fork --logpath /var/log/mongodb.log





SQLITE_DATABASE_FILEPATH = 'data/example.db'


task :create_db => SQLITE_DATABASE_FILEPATH

file SQLITE_DATABASE_FILEPATH do
	@catalog = SummerResearch::Catalog.new(SQLITE_DATABASE_FILEPATH)
		# connect to the SQLite and MongoDB databases
		
	@catalog.setup
		# establish the schema
	@catalog.fetch_course_listing
		# download list of possible catalog years
		# figure out how to search by dept code for each and every catalog year
		# get lists of courses, based on a subset of dept codes, for each and every year
end

# file SQLITE_DATABASE_FILEPATH do
# 	Rake::Task["db_backend:create_db"].invoke
# end

# run 'create_db' before this to download initial data
# (can't list as explict dependency at this time, because I don't know how to easily skip processing an entire catalog year)
task :query_db => [SQLITE_DATABASE_FILEPATH] do
	@catalog = SummerResearch::Catalog.new(SQLITE_DATABASE_FILEPATH)
	
	
	info = @catalog.course_info('CS 101')
	p info
	# @catalog.query do |q|
		
	# end
end

task :wipe_mongo => [SQLITE_DATABASE_FILEPATH] do
	@catalog = SummerResearch::Catalog.new(SQLITE_DATABASE_FILEPATH)
	
	@catalog.course_details_mongo do |db|
		result = db.delete_many
		puts result.n
	end
end








file 'data/programs_of_study.yaml' do
	puts "=== setup data"
	# search for relevant programs of study
	
	list_of_degrees = [
		"Computer Science",
		"Information Technology",
		"Electrical Engineering",
		"Biology",
		"Psychology"
	]
	
	degrees = SummerResearch.search_programs_of_study(list_of_degrees)
	
	
	count = degrees.keys.size
	puts "#{count} programs found for search query."
	
	SummerResearch::Utilities.write_to_file("./programs_of_study.yaml", degrees.to_yaml)
	@programs_of_study = degrees
end


# List all the courses required for one particular program of study.
# Currently not a very advanced procedure, just grabs all of the links on the page.
# (modern equavialent of foo2)
file 'data/required_courses.yaml' => 'data/programs_of_study.yaml' do
	@programs_of_study ||= YAML.load_file("data/programs_of_study.yaml")
	
	
	# TODO: output data on different degrees to different folders.
	
	program_name = "Computer Science, BS"
	url = @programs_of_study[program_name]
	course_list = all_courses_for_degree(url)
	
	SummerResearch::Utilities.write_to_file("./required_courses.yaml", course_list.to_yaml)
	
	@required_courses = course_list
end

task :cs_requirements => ['data/required_courses.yaml', SQLITE_DATABASE_FILEPATH] do
	@required_courses ||= YAML.load_file('data/required_courses.yaml')
	
	
	@catalog = SummerResearch::Catalog.new(SQLITE_DATABASE_FILEPATH)
	
	
	
	# filter out the main Mason Core page. This is not a class, but an overview of the entire core curriculum
	
	main_requirements = 
		@required_courses
		.reject{|catalog_link| catalog_link.id == "Mason Core"}
		.collect do |catalog_link|
			id = catalog_link.id
			
			# puts "============"
			# p id
			data = @catalog.course_info(id)
			# p data
			
			data
		end
	
	
	
	
	
	
	# lexer = DependencyLexer.new(debug: true)
	# lexer = DependencyLexer.new()
	
	
	main_requirements.each do |course_info|
		
		puts course_info.id
		
		regexp = /(\p{L}+ \d+)/ # look for course codes in the requirements lists
		
		
		hard_deps =
		%w[Prerequisite(s) Corequisite(s)]
			.collect do |x|
				requirements = course_info[x]
				# p requirements
				next unless requirements
				requirements.scan(regexp)
			end
			
		
		# "C or higher in CS 105; (COMM 100, and ENGH 302) or (HNRS 110 and HNRS 122, 130, 131, 230 or 240); junior standing (at least 60 credit hours)."
		# ERROR: can't deal with 'or 240'
		# ERROR: can't deal with 'at least 60 credit hours' => 'least 60'
		
		# "Grade of C or better in CS 310, 330, and 367."
		# ERROR: can't deal with 'CS 310, 330, and 367' => 'and 367'
		
		# CS 499 
		# Prerequisite(s): 60 credits and permission of instructor; specific prerequisites vary with nature of topic.
		
		# PHIL 371 - Philosophy of Natural Sciences
		# Prerequisite(s): "3 credits of philosophy, or permission of instructor"
		
		
		
		
		# SWE 443 - Software Architectures
		# Prerequisite(s): Grade of C or better in CS 321 or CS 421 or SWE 321 or SWE 421.
		# IIRC, 421 was re-numbered to 321.
		# Notice that the numbers are the same for CS and SWE
		# this is a cross-listed course.
			# (note that some cross listed courses are exactly the same, but there's some OR course that's not? depending on if you take it as OR or MATH, there are a different number of seats avaiable in the class, and the prereqs are fairly different. This is despite it being the exact same physical lecture section.)
		
		
		
		
		# "#{course} with grade of C or better"
		# "Minimum grade of C in #{course}"
		soft_deps = 
			if course_info["Notes"]
				# [0] PHYS 161
				# [1] PHYS
				# [2] 161
				
				# soft_deps = course_info["Notes"].scan(regexp).collect{ |matches| matches[0] }
				[] # pseudo-return empty array to stub this out
			else
				[] # if "Notes" attribute not set, return empty Array
			end
		
		
		# p hard_deps
		# p soft_deps
		dependencies = hard_deps + soft_deps
		
		
		# p dependencies.flatten.compact.uniq
		puts "---------"
		
		
		
		
		# "math placement test"
		# "Placement Test"
		# "Mathematics Placement Test"
		
		# "algebra tutorial program"
		
		
		
		
		# HNRS 122, 130, 131, 230 or 240
		# CS 262 or 222
		# ECE 301 or 331
		# CS 310, 330, and 367
		# "Grade of C or better in CS 310, 330, and 367."
		# MATH 123 and 124
		# "C or better in MATH 113 or in both MATH 123 and 124."
		
		
		
		
		# "Completion of 45 credits including the Mason core composition and literature requirements, requires a grade of C or better."
		# => ["of 45"]
		
		# "Score of 13 or better on the Math Placement Test, or Grade of C or better in MATH 105, or Grade of C or better in MATH 108, or Grade of C or better in MATH 113."
		# => ["of 13", "MATH 105", "MATH 108", "MATH 113"]
		
		# "C or higher in STAT 346 and a course in Statistics, or STAT 344."
		# "a course in Statistics" ???
			# ACS Gaming specifies that you can take "344 or a course in statistics relevant to your major" [paraphrased] so I have seen precedience for this sort of loose dependency around stat.
			# (but IIRC there aren't currently any courses like that offered at Mason? so why is there this stipulation at all? future-proofing?)
			# 
			# (future-proofing is a cool backend-y sort of thing, but it's weird for that to be exposed to students / other end users)
		
		
		
		
		# === generate "source code"
		puts ">>>>>>>>>>"
		all_deps_text =
		%w[Prerequisite(s) Corequisite(s)]
			.collect do |x|
				requirements = course_info[x]
			end
		all_deps_text = all_deps_text.join("\n")
		
		# p all_deps_text
		# enum =  lexer.lex(all_deps_text)
		# p enum.to_a
		
		parse_dependencies(all_deps_text)
		
		
		
		
		
		dependencies # <-- pseudo-return for block
	end
end

task :parser_test do
	corpus = <<-EOF
		"C or higher in CS 105; (COMM 100, and ENGH 302) or (HNRS 110 and HNRS 122, 130, 131, 230 or 240); junior standing (at least 60 credit hours)."
		
		"Grade of C or better in CS 310, 330, and 367."
		
		CS 499 
		Prerequisite(s): 60 credits and permission of instructor; specific prerequisites vary with nature of topic.
		
		PHIL 371 - Philosophy of Natural Sciences
		Prerequisite(s): "3 credits of philosophy, or permission of instructor"


		SWE 443 - Software Architectures
		Prerequisite(s): Grade of C or better in CS 321 or CS 421 or SWE 321 or SWE 421.
		
		"math placement test"
		"Placement Test"
		"Mathematics Placement Test"

		"algebra tutorial program"
		
		
		
		
		HNRS 122, 130, 131, 230 or 240
		CS 262 or 222
		ECE 301 or 331
		CS 310, 330, and 367
		"Grade of C or better in CS 310, 330, and 367."
		MATH 123 and 124
		"C or better in MATH 113 or in both MATH 123 and 124."
		
		
		
		"Completion of 45 credits including the Mason core composition and literature requirements, requires a grade of C or better."
		
		"Score of 13 or better on the Math Placement Test, or Grade of C or better in MATH 105, or Grade of C or better in MATH 108, or Grade of C or better in MATH 113."
		
		"C or higher in STAT 346 and a course in Statistics, or STAT 344."
		
		
		Mason Core
		 Mason Core UWCU
		 Mason Core UOC
		 Mason Core UQR
		 Mason Core UITC
		 Mason Core UFA
		 Mason Core UGU
		 Mason Core ULIT
		 Mason Core UNSL
		 Mason Core USBS
		 Mason Core UWC
		 Mason Core USYN
	EOF
	
	parse_dependencies(corpus)
end

# class DependencyLexer < Lex::Lexer
# 	tokens(
# 		:NUMBER,
# 		:DEPT
# 	)

# 	# Regular expression rules for simple tokens
# 	rule(:DEPT,   /\p{Lu}{2,4}/)
	
# 	# A regular expression rules with actions
# 	rule(:NUMBER, /\d{3}/) do |lexer, token|
# 		token.value = token.value.to_i
# 		token
# 	end
	
# 	# Define a rule so we can track line numbers
# 	rule(:newline, /\n+/) do |lexer, token|
# 		lexer.advance_line(token.value.length)
# 	end
	
# 	# A string containing ignored characters (spaces and tabs)
# 	ignore " \t"
	
# 	error do |lexer, token|
# 		puts "Illegal character: #{token.value}"
# 	end
# end

def parse_dependencies(all_deps_text)
	# === find relevant "tokens"
	tokens = 
		all_deps_text.split.collect do |fragment|
			# $1 through $9 are the "Pseudo Variables" set by regex matching
				# src: http://stackoverflow.com/questions/6803647/how-to-write-a-ruby-switch-statement-case-when-with-regex-and-backreferences
			
			# NOTE: must be write capture groups for the pseudo variables to be populated
			case fragment
				when /(Mason Core)/
					# ERROR:: this can't be captured right now, because of the space
					[:core_overview,   $1]
				when /(#{ %w[UWCU UOC UQR UITC UFA UGU ULIT UNSL USBS UWC USYN].join('|') })/
					# Exhaustive search for all "mason core" category keys
					# (must trigger before searching for department codes)
					[:core_category,   $1]
				when /(\d{3}-level)/
					# ex: 600-level course
					[:year_level_category, $1]
				when /(\p{Lu}{2,4})/ # 2-4 capital letters
					[:department_code, $1]
				when /(\d{3})/       # 3 digits
					[:course_number,   $1]
				else
					nil
			end
			# NOTE: assuming the only usage of three-digit numbers is in course codes. However, some courses gate by the number of credits, so maybe a three-digit number could appear there? It seems unlikely, (60 and 90 seem like better choices, given 120 to graduate) but making a note in case an error comes up in the future.
		end
	tokens.compact!
	
	puts "vvvvvvvvvvvvv"
	p tokens
	puts "^^^^^^^^^^^^^"
	
	
	# === use "tokens" to assemble course names
	return if tokens.empty?
	
	
	unless tokens.first[0] == :department_code
		# Expect that the first token is a department code
		# Need to specify department codes if there are any course numbers specified
		if tokens.any?{|type, token| type == :course_number }
			raise "ERROR: first token should be a department code"
		end
	end
	
	
	most_recent_dept_code = tokens.first[0]
	
	out = 
		tokens.collect do |type, token|
			most_recent_dept_code = token if type == :department_code
			
			if type == :course_number
				[most_recent_dept_code, token].join(' ')
			end
		end
	
	out.compact!
	
	puts "> #{out.inspect}"
	
	
	return out
end



# prereq information only, specific format, for all classes in the 2016-2017 catalog year
# CS 330 : CS 101, CS 212
# COURSE : DEP1, DEP2
# (only show direct dependencies)
# (these numbers are only for demonstration, I don't know this is real data or not)
task :qian_hu_data do
	@catalog = SummerResearch::Catalog.new(SQLITE_DATABASE_FILEPATH)
	
	
	
	
	
	# this is kinda bad form, because you don't want to be able to call this class outside of the context of @catalog, because the database may not be created yet, or there may not be a connection, etc etc etc
	# catalog_year = SummerResearch::Catalog::CatalogYear.where(:year_range => '2016-2017')
	
	
	
	out = nil
	
	@catalog.activerecord_query do |course_model, catologyear_model|
		# === update index with ALL DEPARTMENTS for the most recent catalog year
		catalog_year = catologyear_model.where(:year_range => '2016-2017')
		
		@catalog.populate_course_index(catalog_year)
		
		
		# === fetch specific information of ALL CLASSES in the current year
		all_courses_in_year = 
			catologyear_model.where(:year_range => '2016-2017')
			                 .first.courses
		
		p all_courses_in_year
		raise "ERROR: expected a course_model" unless all_courses_in_year.first.is_a? course_model
		
		
		# filter out the main Mason Core pages.
		# These do not have the same structure as other "real courses", and may cause problems.
		all_courses_in_year = all_courses_in_year.reject{|course| course.dept == "Mason Core"}
		
		
		out = 
			all_courses_in_year.collect do |course_record|
				@catalog.fetch_course_info(course_record)
			end
	end
	
	main_requirements = out
	
	
	
	# === parse direct prereqs for each and every class
	p main_requirements.collect{  |course_info| course_info.id  }
	data = 
		main_requirements.uniq.collect do |course_info|
			name = course_info.id
			
			puts "-=-=-=-=-=-=-=-="
			deps = course_info["Prerequisite(s)"]
				puts "=>  #{deps.inspect}"
			deps = deps.nil? ? [] : parse_dependencies(deps)
				puts "=>  #{deps.inspect}"
			deps = [] if deps.nil?
				puts "=>  #{deps.inspect}"
			
			# oooh yeah. parse_dependencies can return nil, even if the dependecies field is set
				# ex) CS 499 => "60 credits and permission of instructor; specific prerequisites vary with nature of topic."
			
			
			raise "ERROR: #{course_info.id} => #{deps.inspect} "if deps.nil? or deps == ''
			
			[name, deps]
		end
	p data
	
	# === convert to desired output format
	filepath = File.expand_path('./qian_sample_4.txt', SummerResearch::Utilities::DATA_DIR)
	File.open(filepath, 'w') do |f|
		data.each do |name, deps|
			name = name.tr(' ', '-')
			deps.collect!{  |x| x.tr(' ', '-')  }
			
			
			f.puts "#{name}:#{deps.join(',')}"
		end
	end
	
end




task :get_info do
	@catalog = SummerResearch::Catalog.new(SQLITE_DATABASE_FILEPATH)
	p @catalog.course_info("STAT 344")
end


# TODO: reimplement these tests calling actual code from Catalog
# maybe use instance_eval? probably need to break up the code in Catalog a little better, to allow for testing without having to just copy the code over like this
namespace :catalog_test do
	# all of these tests use the 2016-2017 catalog year, catoid = "29"
	
	task 'data/CS_course_list.html' do
		# little bit of code to get the page where the CS courses 
		# copied from Catalog#search_by_department()
		catoid, navoid, dept_code = %w[29 6272 CS]
		
		url = "http://catalog.gmu.edu/content.php?filter%5B27%5D=#{dept_code}&filter%5B29%5D=&filter%5Bcourse_type%5D=-1&filter%5Bkeyword%5D=&filter%5B32%5D=1&filter%5Bcpage%5D=1&cur_cat_oid=#{catoid}&expand=&navoid=#{navoid}&search_database=Filter#acalog_template_course_filter"
		
		xml = Nokogiri::HTML(open(url))
		
		
		# cache data on the disk
		SummerResearch::Utilities.write_to_file("./CS_course_list.html", xml)
	end
	
	task :multiple_page_iteration => 'data/CS_course_list.html' do
		filepath = File.expand_path("./CS_course_list.html", SummerResearch::Utilities::DATA_DIR)
		xml = Nokogiri::HTML(open(filepath))
		
		links = CatalogTest.page_links(xml)
		
		puts links
		pages = links.collect{  |url|  Nokogiri::HTML(open(url))  }
		
		
		# add the original page to the set of all pages
		pages.unshift(xml)
		
		
		# === Get all links from each and every page
		data = 
			pages.collect do |xml|
				# === copied from Catalog#search_by_department()
				
				node = xml.css('td.block_content_outer table')[3]
					# SummerResearch::Utilities.write_to_file("./search.html", xml) if node.nil?
				# NOTE: sometimes fails to find courses.
				# just retry the request again, and you should be able to get it.
				while node.nil?
					puts "nope. wait a sec..."
					sleep(3.0) # wait a bit before retrying
					puts "retrying #{dept_code}..."
					
					xml = Nokogiri::HTML(open(url))
					node = xml.css('td.block_content_outer table')[3]
				end
				
				
				# NOTE: results are paginated. Should get info from ALL pages, not just the first one.
				
				tr_list = node.css('tr')[2..-1]
				
				# tr_list.each{|x| puts x.class }
				tr_list.collect{  |x| SummerResearch.get_all_weird_link_urls(x)  }.flatten
			end
		
		# === Show the courses gathered from the links
		puts data.flatten.collect{  |catalog_link|  catalog_link.id  }
	end
	
	
	# show the page counts for various degrees in the catalog
	task :page_counts do
		departments_with_999 = %w[ASTR BIOD BENG BINF BIOS CHEM CEIE CLIM COMM CSI CSS CS CONF CRIM CULT ECON EDUC ECE ENGH EVPP GGS GOVT HAP HE HIST IT LING MATH MUSI NEUR NURS PSCI PHYS PSYC PUBP RHBS SOCI STAT SEOR]
		
		# department_codes = departments_with_999
		department_codes = CatalogTest.all_department_codes()
		
		department_codes.each do |dept_code|
			# little bit of code to get the page where the CS courses 
			# copied from Catalog#search_by_department()
			catoid, navoid = %w[29 6272]
			
			url = "http://catalog.gmu.edu/content.php?filter%5B27%5D=#{dept_code}&filter%5B29%5D=&filter%5Bcourse_type%5D=-1&filter%5Bkeyword%5D=&filter%5B32%5D=1&filter%5Bcpage%5D=1&cur_cat_oid=#{catoid}&expand=&navoid=#{navoid}&search_database=Filter#acalog_template_course_filter"
			
			xml = Nokogiri::HTML(open(url))
			
			
			
			
			
			# copied from :multiple_page_iteration task above
			links = CatalogTest.page_links(xml)
			page_count = links.length + 1
			
			puts page_count
			# need to add 1 to page count, because there is no link to the current page, ie the first page
			
			
			
			
			# query all dept codes at once to see how many pages will fit before elipsis is inserted
			# http://catalog.gmu.edu/content.php?filter%5B27%5D=-1&filter%5B29%5D=&filter%5Bcourse_type%5D=-1&filter%5Bkeyword%5D=&filter%5B32%5D=1&filter%5Bcpage%5D=1&cur_cat_oid=29&expand=&navoid=6272&search_database=Filter#acalog_template_course_filter
			# 
			# => as long as there are 11 or fewer pages,
			#    should be able to traverse without any problems
			
			
			# can easily chuck the numbers that get printed into a histogram for easy viewing
			# http://www.shodor.org/interactivate/activities/Histogram/
			# => 1 page  => 140
			#    2 pages => ~20
			#    3 pages => a couple
		end
	end
end
module CatalogTest
	class << self
		def all_department_codes
			# === copied from Catalog#fetch_course_listing()
			catoid         = "29"
			courses_navoid = "6272"
			url = "http://catalog.gmu.edu/content.php?catoid=#{catoid}&navoid=#{courses_navoid}"
			
			
			# === copied from Catalog#all_department_codes()
			xml = Nokogiri::HTML(open(url))
			
			#course_search > table > tbody > tr:nth-child(4) > td:nth-child(1) > select
			segment = xml.css('#course_search table tr:nth-child(4) > td:nth-child(1) > select > option')
				# Utilities.write_to_file("./department_codes_fragment.html", segment)
			
			departments = segment.collect{  |option_node|  option_node["value"]  } 
			departments.shift # remove the first one, which is just -1, the default nonsense value
			
			return departments
		end
		
		def page_links(nokogiri_html)
			fragment = nokogiri_html.css('td.block_content_outer table')
			page_navigation = fragment.css('td').last
			
			# puts page_navigation
			
			
			relative_links = page_navigation.xpath('a/@href')
			links          = relative_links.collect{  |x| "http://catalog.gmu.edu" + x.value  }
			
			return links
		end
	end
end








def get_dependencies(course_info)
	
end

def all_courses_for_degree(url_to_program_requirements_page)
	puts "=== run processing"
	
	# === take one degree program, and walk the dependencies for all courses in the degree
	# (get all relevant courses)
	
	fragment = SummerResearch.requirements_subtree(url_to_program_requirements_page)
	
	# TODO: need to improve this selector. catching some false positives.
	# wait, variable 'fragment' is a list...
	course_list = SummerResearch.get_all_weird_link_urls(fragment)
	
	
	
	
	# TODO: remove dupicate entries in the list of courses
		# not just as simple as removing duplicates from list
		# need to remove when two tuples have the same first element
		# also - want to keep original ordering
	# NOTE: this may not be necessary if the selection filter on links is improved
	
	
	return course_list
end













# this is just a template
# 1 2 3 (list the full foo execution chain?)
task :pathwayX do
	
end













# ==================
# v  tests, based on old pathways






# === test conversion of CatalogLink object => CourseInfo object
# (NOTICE: this is not a unit test, just a bunch of diagnostics)
# Used for fetching detailed information on a specific course from the catalog.
# Currently does not save documents in Mongo DB.
# 
# There are currently 3 different major types of document pages stored in the online catalog
# CourseInfo should be able to parse all of the differnt variations.
# These tests throw a considerable variety of data at CourseInfo, and print diagonstics.
# 
# Viewing the diagnostic outputs from these tasks should help a person see
# how the system currently is classifying these documents.
# (NOTE: this is a manually designed and implemented classification, not machine learning)
task :test_course_info_fetch => [:one_degree, :debug, :debug_verbose, :all_degrees_debug]
namespace :test_course_info_fetch do
	task :sample_data do
		# NOTE: easily get data for this table from the intermediate file required_courses.csv
		# (UPDATE: need to figure out a similarly easy way to rip this data out from the DB)
		
		# NOTE: not all courses specify all attributes. 
		#   ex) If there are no corequisites, the field is omitted
		sample = [
			[
				"CS 101",
				"Preview of Computer Science",
				"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302776&print"
			],
			[
				"CS 465",
				"Computer Systems Architecture",
				"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302800&print"
			],
			[
				"CS 475",
				"Concurrent and Distributed Systems",
				"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302803&print"
			],
			[
				"CS 330",
				"Formal Methods and Models",
				"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=302788&print"
			],
			[
				"STAT 344",
				"Probability and Statistics for Engineers and Scientists I",
				"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=306778&print"
			],
			[
				"PSYC 320",
				"Psychological Tests and Measurements",
				"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=306130&print"
			],
			[
				"EVPP 110",
				"The Ecosphere: An Introduction to Environmental Science I",
				"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=303982&print"
			],
			[
				"Mason Core UGU",
				"Global Understanding",
				"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=308635"
			]
		].collect{|a,b,c| SummerResearch::CatalogLink.new(a, b, c, 'manual') }
		
		# TODO: figure out what the anatomy of a course is
		# * CS 101
		# * Preview of Computer Science
		# * Description
		# * Section ID?
		# --- these are all different things


		# TODO: if department is not found, error should alert the user that list of courses needs to be pulled down from the Catalog for that department before asking for a course.
		
		@pw_sample = sample
	end
	
	
	
	# [CatalogLink] => [CourseInfo] DEBUG
	# only shows error messages when the system fails to fetch a page
	# otherwise just prints dots to let you know progress is happening
	# allows you to see errors across all entries (does not stop after the first error)
	# 
	# (input dataset: sample dataset)
	task :debug => [:sample_data] do
		@catalog = SummerResearch::Catalog.new(SQLITE_DATABASE_FILEPATH)
		
		puts "=== run processing"
		
		# @pw_sample --> course_data
		# 
		# sample data set => [CatalogLink] 
		# [CatalogLink] => [CourseInfo] DEBUG
		course_data = CourseInfoDiagnostic.debug(@catalog, @pw_sample) 
	end
	
	# [CatalogLink] => [CourseInfo] DEBUG VERBOSE
	# prints extensive information on the types of data being detected.
	# type signatures and debug information displayed for all entries.
	# allows you to see errors across all entries (does not stop after the first error)
	# 
	# (input dataset: sample dataset)
	task :debug_verbose => [:sample_data] do
		@catalog = SummerResearch::Catalog.new(SQLITE_DATABASE_FILEPATH)
		
		puts "=== run processing"
		
		# @pw_sample --> course_data
		# 
		# sample data set => [CatalogLink] 
		# [CatalogLink] => [CourseInfo] DEBUG VERBOSE
		course_data = CourseInfoDiagnostic.debug_verbose(@catalog, @pw_sample)
	end
	
	
	# course [CatalogLink] => [CourseInfo] DEBUG
	# no debug information. just prints the course ids for the classes being downloaded
	# (input dataset: all courses from CS degree)
	task :one_degree_debug => "data/programs_of_study.yaml" do
		@programs_of_study ||= YAML.load_file("data/programs_of_study.yaml")
		
		@catalog = SummerResearch::Catalog.new(SQLITE_DATABASE_FILEPATH)
		
		
		
		programs = [
			"Computer Science, BS",
			"Applied Computer Science, BS",
			"Biology, BA",
			"Biology, BS",
			"Psychology, BA"
		]
		
		program_name = "Computer Science, BS"
		url = @programs_of_study[program_name]
		courses = all_courses_for_degree(url)
		
		
		
		
		puts "=== run processing"
		course_data = CourseInfoDiagnostic.debug(@catalog, courses) # course [CatalogLink] => [CourseInfo] RELEASE VERSION
		
		SummerResearch::Utilities.write_to_file('./course_info.yaml', course_data.to_yaml)
	end
	
	# [CatalogLink] => [CourseInfo] DEBUG
	# (input dataset: ALL courses from ALL majors in the sample set)
	# 
	# same core procedure as pw6, but with a much bigger data set
	task :all_degrees_debug do
		@catalog = SummerResearch::Catalog.new(SQLITE_DATABASE_FILEPATH)
		
		puts "=== load data..."
		@programs_of_study ||= YAML.load_file("data/programs_of_study.yaml")
		
		
		puts "=== cycle through programs of study..."
		
		programs = [
			"Computer Science, BS",
			"Applied Computer Science, BS",
			"Biology, BA",
			"Biology, BS",
			"Psychology, BA"
		]
		programs.each do |degree_name|
			puts "=== Getting info for: #{degree_name}"
			url = @programs_of_study[degree_name]
			courses = all_courses_for_degree(url)
			# If the program list has a weird link in it, then the foo2 will fail before reaching the end of the list
				# url = @env.degrees[degree_name]
				# course_list = SummerResearch.degree_requirements(url)
				# puts "test"
			# failure occurs inside of SummerResearch.degree_requiremnts
			
			puts "=== analyzing courses... "
			course_data = CourseInfoDiagnostic.debug(@catalog, courses)
		end
		
		# errors from: SummerResearch::CourseInfo#fetch
		# two other page formats:
			# +  new page format: attemps to give more structure using <p> to separate into sub-regions, but actually malformed
				# ^ seems to be for more recent courses? not really sure why the markup is different
			# +  Mason Core pages: Totally different pages, because these are not actually courses. They are "aliases" of sorts for entire lists of courses.
		
		
		
		# NOTE: perhaps not all majors work right now? so be careful of that too
		
		
		
		# NOTE: the following programs of study only use Type A or Type B catalog links
			# "Computer Science, BS",
			# "Biology, BA",
		# NOTE: the following programs of study are known to list courses with Type C catalog links
			# "Applied Computer Science, BS",
			# "Biology, BS",
			# "Psychology, BA"
	end
	
	
	task :extended_set => [:sample_data] do
		# ASSUME: requires that you load up ALL COURSES for the current catalog year, as was done when generating Qian Hu's dataset. Not going to copy that code here, just assuming it has been done already.
			# (This only uses the index data, it should not use data from Mongo)
		@catalog = SummerResearch::Catalog.new(SQLITE_DATABASE_FILEPATH)
		
		
		sample = [
			[
				"MATH 551",
				"???",
				"http://catalog.gmu.edu/preview_course.php?catoid=29&coid=305092"
			]
		].collect{|a,b,c| SummerResearch::CatalogLink.new(a, b, c, 'manual') }
		
		# dataset = @pw_sample + sample
		dataset = sample
		
		
		# NOTE: if @catalog is not set, debug_verbose() still works, but actually outputs far less data that debug()
		course_data = CourseInfoDiagnostic.debug(@catalog, dataset)
		course_data = CourseInfoDiagnostic.debug_verbose(@catalog, dataset)
	end
end


module CourseInfoDiagnostic
class << self
	# I think foo13 is just a precursor to the other ones?
	# like, really why would I ever want to run this variant?
	# It's just gonna fail to give any useful diagnostic information whatsoever
	def foo13(catalog, course_list)
		output_data = 
			course_list.collect do |course|
				puts course.id
				course_info_from_catalog_link(catalog, course).fetch
			end
		
		return output_data
	end
	
	
	# find courses that fail parsing
	# want to see some examples of the unexpected
	# 
	# prints dots to let you know something is happening
	# only prints out courses that are "weird"
	# 
	# Does basicaly the same thing as foo13, but includes extra code to help report errors.
	def debug(catalog, course_list)
		flag = true
		
		course_list.each do |course|
			begin
				course_info_from_catalog_link(catalog, course).fetch
			rescue StandardError => e
				if flag
					puts ""
					flag = false
				end
				
				puts "course id:   #{course.id}"
				puts "description: #{course.description}"
				puts "url:         #{course.url}"
				puts "Catalog Link format: #{course.link_type}"
				# throw e
				
				# output the data from the exception
				# (the program will still continue to run)
				# (resulting in all errors printed in one place)
				puts e.message
				e.backtrace.each do |line|
					puts "\t" + line
					# indent the lines of the backtrace.
					# makes it easier to see things when you start getting multiple errors
				end
				puts "=============="
				puts
				puts
			else
				flag = true
				print "."
			end
		end
		
		puts ""
	end
	
	# Like debug, but with even more debug information. 
	# 
	# most of the code in this method comes directly from 'debug()' above
	# only the method call on CouseInfo has been changed from #fetch to #test_types
	def debug_verbose(catalog, course_list)
		flag = true
		
		course_list.each do |course|
			begin
				course_info_from_catalog_link(catalog, course).test_types
			rescue StandardError => e
				if flag
					puts ""
					flag = false
				end
				
				puts "course id:   #{course.id}"
				puts "description: #{course.description}"
				puts "url:         #{course.url}"
				puts "Catalog Link format: #{course.link_type}"
			else
				flag = true
			ensure
				puts "=============="
				puts
				puts
			end
		end
		
		puts ""
	end
	
	
	
	# NOTE: this connects to the SQLite DB to convert between catoid => 'catalog year'
	def course_info_from_catalog_link(catalog, catalog_link)
		course = catalog_link
		
		
		dept, course_number = SummerResearch::Catalog.parse_course_id(course.id)
		
		url = course.url
		
		catoid = SummerResearch::Catalog.catoid_from_url(url)
		# convert catoid => 'catalog year' using the data in the new Catalog class
		catalog_year = catalog.catoid_to_catalog_year(catoid)
		
		
		return SummerResearch::CourseInfo.new(dept, course_number, catalog_year, url)
	end
end
end




